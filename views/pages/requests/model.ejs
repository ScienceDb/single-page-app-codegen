import { requestGraphql } from '../utils'
import getAttributes from './requests.attributes'

export default {

  tableTemplate(url) {
    let query = `query {csvTableTemplate<%- nameCp _%>}`

    /**
     * Debug
     */
    console.log("tableTemplate.query: gql:\n", query);

    return requestGraphql({ url, query });
  },

  /**
   * getCountItems
   *
   * Get count of items from GraphQL Server.
   *
   * @param {String} url GraphQL Server url
   * @param {String} searchText Text string currently on search bar.
   * @param {String} ops Object with adittional query options.
   */
  getCountItems(url, searchText, ops) {
    //search
    var s = getSearchArgument('<%- nameLc _%>', searchText, ops);

    var query = '';

    //if has search
    if (s !== null) {
      query = `{ count<%- namePlCp _%>(${s}) }`;
    }
    else {
      query = `{ count<%- namePlCp %> }`;
    }

    /**
     * Debug
     */
    console.log("getCountItems.query: gql:\n", query);

    return requestGraphql({ url, query });
  },

<%if(paginationType === 'limitOffset') {-%>
  /**
   * getItems
   *
   * Get items from GraphQL Server.
   *
   * @param {String} url GraphQL Server url
   * @param {String} searchText Text string currently on search bar.
   * @param {String} orderBy Order field string.
   * @param {String} orderDirection Text string: asc | desc.
   * @param {Number} paginationOffset Offset.
   * @param {Number} paginationLimit Max number of items to retreive.
   * @param {String} ops Object with adittional query options.
   */
  getItems(url, searchText, orderBy, orderDirection, paginationOffset, paginationLimit, ops) {
    //search
    var s = getSearchArgument('<%- nameLc _%>', searchText, ops);

    //order
    var o = null;
    if (orderBy !== '' && orderBy !== null) {
      let upOrderDirection = String(orderDirection).toUpperCase();
      o = `order: [ {field: ${orderBy}, order: ${upOrderDirection}} ]`;
    }

    //pagination
    var p = `pagination: {offset: ${paginationOffset}, limit: ${paginationLimit}}`

    var query = '';
    var qbody = `
<%if(isDefaultId){-%>
            <%- internalId _%>,
<%}-%>
<%_for( let i=0; i<attributesArr.length; i++ ){-%>
            <%- attributesArr[i][0] -%>,
<%}-%>
<%_for( let i=0; i<sortedAssociations.length; i++ ){
  if(sortedAssociations[i].type === 'to_one' || sortedAssociations[i].type === 'generic_to_one') {-%>
            <%- sortedAssociations[i].relationName -%>{ <%- sortedAssociations[i].internalId -%> },
<%}}-%>`

    //if has search
    if (s !== null) {
      //if has order
      if (o != null) {

        query =
          `{ <%- namePlLc _%>( ${s}, ${o}, ${p} ) {
            ${qbody}
           }}`
      }
      else {

        query =
          `{ <%- namePlLc _%>( ${s}, ${p} ) {
            ${qbody}
           }}`
      }
    }
    else {
      //if has order
      if (o != null) {

        query =
          `{ <%- namePlLc _%>( ${o}, ${p} ) {
            ${qbody}
           }}`
      }
      else {

        query =
          `{ <%- namePlLc _%>( ${p} ) {
            ${qbody}
           }}`
      }
    }

    /**
     * Debug
     */
    console.log("getData.query: gql:\n", query);

    return requestGraphql({ url, query });

  },
<%} else if(paginationType === 'cursorBased') {-%>
  /**
   * getItemsConnection
   *
   * Get items from GraphQL Server using a cursor-based-connection.
   *
   * @param {String} url GraphQL Server url
   * @param {String} searchText Text string currently on search bar.
   * @param {String} orderBy Order field string.
   * @param {String} orderDirection Text string: asc | desc.
   * @param {Object} variables Object with cursor-based-pagination variables.
   * @param {String} ops Object with additional query options.
   */
  getItemsConnection(url, searchText, orderBy, orderDirection, variables, ops) {
    //search
    var s = getSearchArgument('<%- nameLc _%>', searchText, ops);

    //order
    var o = null;
    if (orderBy !== '' && orderBy !== null) {
      let upOrderDirection = String(orderDirection).toUpperCase();
      o = `order: [ {field: ${orderBy}, order: ${upOrderDirection}} ]`;
    }

    var query = '';
    var qbody = `
          pageInfo {
            startCursor
            endCursor
            hasPreviousPage
            hasNextPage
          }
          edges {
            node {
<%if(isDefaultId){-%>
              <%- internalId _%>,
<%}-%>
<%_for( let i=0; i<attributesArr.length; i++ ){-%>
              <%- attributesArr[i][0] -%>,
<%}-%>
<%_for( let i=0; i<sortedAssociations.length; i++ ){
      if(sortedAssociations[i].type === 'to_one' || sortedAssociations[i].type === 'generic_to_one') {-%>
              <%- sortedAssociations[i].relationName -%>{ <%- sortedAssociations[i].internalId -%> },
<%}}-%>
            }
          }`

    //if has search
    if (s !== null) {
      //if has order
      if (o != null) {

        query =
          `query <%- namePlLc _%>Connection($pagination: paginationCursorInput)
            { <%- namePlLc _%>Connection( ${s}, ${o}, pagination: $pagination ) {
              ${qbody}
            }}`
      }
      else {

        query =
          `query <%- namePlLc _%>Connection($pagination: paginationCursorInput)
            { <%- namePlLc _%>Connection( ${s}, pagination: $pagination ) {
              ${qbody}
            }}`
      }
    }
    else {
      //if has order
      if (o != null) {

        query =
          `query <%- namePlLc _%>Connection($pagination: paginationCursorInput)
          { <%- namePlLc _%>Connection( ${o}, pagination: $pagination ) {
            ${qbody}
          }}`
      }
      else {

        query =
          `query <%- namePlLc _%>Connection($pagination: paginationCursorInput)
          { <%- namePlLc _%>Connection( pagination: $pagination ) {
            ${qbody}
          }}`
      }
    }

    /**
     * Debug
     */
    console.log("getItemsConnection.query: gql:\n", query);
    console.log("getItemsConnection.variables: gql:\n", variables);

    return requestGraphql({ url, query, variables });

  },
<%}-%>

  /**
   * createItem
   *
   * Add new <%- nameCp %> item on GraphQL Server.
   *
   * @param {String} url GraphQL Server url.
   * @param {Object} variables Object with values to create new <%- nameCp %> item.
   */
  createItem(url, variables) {
    var query =
      `mutation
        add<%- nameCp %>(
<%if(!isDefaultId){-%>
          $<%- internalId _%>:ID!,
<%}-%>
<%_for( let i=0; i<attributesArr.length; i++ ){
  /*
   * Render each attribute, except FK attributes and internalId.
   */

  let a = attributesArr[i][0];
  let isForeignKey = (hasOwnForeingKeys&&ownForeignKeysArr.includes(a));
  if(!isForeignKey && (attributesArr[i][0] !== internalId)) {
-%>
          $<%- attributesArr[i][0] _%>:<%- attributesArr[i][1] _%>,
<%}}-%>
<%for( let i=0; i<sortedAssociations.length; i++ ){
  /*
   * Render each toAdd attributes for to_one associations.
   */

  if(sortedAssociations[i].type === 'to_one' || sortedAssociations[i].type === 'generic_to_one') {
-%>
          $add<%- sortedAssociations[i].relationNameCp _%>: ID,
<%}}-%>
<%_for( let i=0; i<sortedAssociations.length; i++ ){
  /*
   * Render each toAdd attributes for to_many associations.
   */

  if(sortedAssociations[i].type === 'to_many' || sortedAssociations[i].type === 'to_many_through_sql_cross_table' || sortedAssociations[i].type === 'generic_to_many') {
-%>
          $add<%- sortedAssociations[i].relationNameCp _%>: [ID],
<%}}-%>
          ) { add<%- nameCp %>(
<%if(!isDefaultId){-%>
            <%- internalId _%>:$<%- internalId _%>,
<%}-%>
<%_for( let i=0; i<attributesArr.length; i++ ){
  /*
   * Render each attribute, except FK attributes and internalId.
   */

  let a = attributesArr[i][0];
  let isForeignKey = (hasOwnForeingKeys&&ownForeignKeysArr.includes(a));
  if(!isForeignKey && (attributesArr[i][0] !== internalId)) {
-%>
            <%- attributesArr[i][0] _%>:$<%- attributesArr[i][0] _%>,
<%}}-%>
<%for( let i=0; i<sortedAssociations.length; i++ ){
  /*
   * Render each toAdd attributes for to_one associations.
   */

  if(sortedAssociations[i].type === 'to_one' || sortedAssociations[i].type === 'generic_to_one') {
-%>
            add<%- sortedAssociations[i].relationNameCp _%>: $add<%- sortedAssociations[i].relationNameCp _%>,
<%}}-%>
<%_for( let i=0; i<sortedAssociations.length; i++ ){
  /*
   * Render each toAdd attributes for to_many associations.
   */

  if(sortedAssociations[i].type === 'to_many' || sortedAssociations[i].type === 'to_many_through_sql_cross_table' || sortedAssociations[i].type === 'generic_to_many') {
-%>
            add<%- sortedAssociations[i].relationNameCp _%>: $add<%- sortedAssociations[i].relationNameCp _%>,
<%}}-%>
          ) {
<%if(isDefaultId){-%>
            <%- internalId _%>,
<%}-%>
<%_for( let i=0; i<attributesArr.length; i++ ){-%>
            <%- attributesArr[i][0] _%>,
<%}-%>
<%_for( let i=0; i<sortedAssociations.length; i++ ){
  if(sortedAssociations[i].type === 'to_one' || sortedAssociations[i].type === 'generic_to_one') {-%>
            <%- sortedAssociations[i].relationName -%>{ <%- sortedAssociations[i].internalId -%> },
<%}}-%>
          } }`;

    /**
     * Debug
     */
    console.log("createItem.query: gql:\n", query);
    console.log("createItem.variables: gql:\n", variables);

    return requestGraphql({ url, query, variables });
  },

  /**
   * updateItem
   *
   * Update <%- nameCp %> item on GraphQL Server.
   *
   * @param {String} url GraphQL Server url.
   * @param {Object} variables Object with values to update the given <%- nameCp %> item.
   */
  updateItem(url, variables) {
    var query =
      `mutation
        update<%- nameCp %>(
          $<%- internalId _%>:ID!
<%_for( let i=0; i<attributesArr.length; i++ ){
  /*
   * Render each attribute, except FK attributes and internalId.
   */

  let a = attributesArr[i][0];
  let isForeignKey = (hasOwnForeingKeys&&ownForeignKeysArr.includes(a));
  if(!isForeignKey && (attributesArr[i][0] !== internalId)) {
-%>
          $<%- attributesArr[i][0] _%>:<%- attributesArr[i][1] _%>,
<%}}-%>
<%for( let i=0; i<sortedAssociations.length; i++ ){
  /*
   * Render each toAdd & toRemove attributes for to_one associations.
   */

  if(sortedAssociations[i].type === 'to_one' || sortedAssociations[i].type === 'generic_to_one') {
-%>
          $add<%- sortedAssociations[i].relationNameCp _%>: ID,
          $remove<%- sortedAssociations[i].relationNameCp _%>: ID,
<%}}-%>
<%_for( let i=0; i<sortedAssociations.length; i++ ){
  /*
   * Render each toAdd attributes for to_many associations.
   */

  if(sortedAssociations[i].type === 'to_many' || sortedAssociations[i].type === 'to_many_through_sql_cross_table' || sortedAssociations[i].type === 'generic_to_many') {
-%>
          $add<%- sortedAssociations[i].relationNameCp _%>: [ID],
          $remove<%- sortedAssociations[i].relationNameCp _%>: [ID],
<%}}-%>
          ) { update<%- nameCp %>(
<%if(isDefaultId){-%>
            <%- internalId _%>:$<%- internalId _%>,
<%} else {-%>
            <%- internalId _%>: $<%- internalId %>
<%}-%>
<%_for( let i=0; i<attributesArr.length; i++ ){
  /*
   * Render each attribute, except FK attributes and internalId.
   */

  let a = attributesArr[i][0];
  let isForeignKey = (hasOwnForeingKeys&&ownForeignKeysArr.includes(a));
  if(!isForeignKey && (attributesArr[i][0] !== internalId)) {
-%>
            <%- attributesArr[i][0] _%>: $<%- attributesArr[i][0] _%>,
<%}}-%>
<%for( let i=0; i<sortedAssociations.length; i++ ){
  /*
   * Render each toAdd & toRemove attributes for to_one associations.
   */

  if(sortedAssociations[i].type === 'to_one' || sortedAssociations[i].type === 'generic_to_one') {
-%>
            add<%- sortedAssociations[i].relationNameCp _%>: $add<%- sortedAssociations[i].relationNameCp _%>,
            remove<%- sortedAssociations[i].relationNameCp _%>: $remove<%- sortedAssociations[i].relationNameCp _%>,
<%}}-%>
<%_for( let i=0; i<sortedAssociations.length; i++ ){
  /*
   * Render each toAdd attributes for to_many associations.
   */

  if(sortedAssociations[i].type === 'to_many' || sortedAssociations[i].type === 'to_many_through_sql_cross_table' || sortedAssociations[i].type === 'generic_to_many') {
-%>
            add<%- sortedAssociations[i].relationNameCp _%>: $add<%- sortedAssociations[i].relationNameCp _%>,
            remove<%- sortedAssociations[i].relationNameCp _%>: $remove<%- sortedAssociations[i].relationNameCp _%>,
<%}}-%>
          ) {
<%if(isDefaultId){-%>
            <%- internalId _%>,
<%}-%>
<%_for( let i=0; i<attributesArr.length; i++ ){-%>
            <%- attributesArr[i][0] _%>,
<%}-%>
<%_for( let i=0; i<sortedAssociations.length; i++ ){
  if(sortedAssociations[i].type === 'to_one' || sortedAssociations[i].type === 'generic_to_one') {-%>
            <%- sortedAssociations[i].relationName -%>{ <%- sortedAssociations[i].internalId -%> },
<%}}-%>
          } }`;

    /**
     * Debug
     */
    console.log("updateItem.query: gql:\n", query);
    console.log("updateItem.variables: gql:\n", variables);

    return requestGraphql({ url, query, variables });
  },

  /**
   * deleteItem
   *
   * Delete an item on GraphQL Server.
   *
   * @param {String} url GraphQL Server url.
   * @param {Object} variables Object with values needed to delete the <%- nameCp %> item.
   */
  deleteItem(url, variables) {
    var query =
      `mutation
        delete<%- nameCp %>(
          $<%- internalId _%>:ID!
        ) {
          delete<%- nameCp %>(
            <%- internalId _%>:$<%- internalId -%>

        ) }`

    /**
     * Debug
     */
    console.log("deleteItem.query: gql:\n", query);
    console.log("deleteItem.variables: gql:\n", variables);

    return requestGraphql({ url, query, variables });
  },

<%for( let i=0; i<sortedAssociations.length; i++ ){-%>
<%
  /**
   * Filters
   * 
   * association types:
   *   - to_many
   *   - to_many_through_sql_cross_table
   *   - generic_to_many
   *   - to_one
   *   - generic_to_one
   * 
   * limitOffset:
   *   - get<AssociatedModel>Filter
   * 
   * cursorBased:
   *   - get<AssociatedModel>Connection
   * 
   */
-%>
<%
  /**
   * limitOffset
   */
-%>
<%if(sortedAssociations[i].paginationType === 'limitOffset') {-%>
  /**
   * get<%- sortedAssociations[i].relationNameCp %>Filter
   *
   * Get <%- sortedAssociations[i].targetModelPlLc %> filter records associated to the given <%- nameLc %> record
   * through association '<%- sortedAssociations[i].relationNameCp %>', from GraphQL Server.
   *
   *
   * @param {String} url GraphQL Server url
   * @param {Number} itemId Model item internalId.
   * @param {String} label Label name.
   * @param {String} sublabel Sublabel name.
   * @param {String} searchText Text string currently on search bar.
   * @param {Number} paginationOffset Offset.
   * @param {Number} paginationLimit Max number of items to retreive.
   * @param {String} ops Object with adittional query options.
   */
  get<%- sortedAssociations[i].relationNameCp %>Filter(url, itemId, label, sublabel, searchText, paginationOffset, paginationLimit, ops) {
<%
  /**
   * to_many
   * to_many_through_sql_cross_table
   * generic_to_many
   */
-%>
<%_if( sortedAssociations[i].type === 'to_many' || sortedAssociations[i].type === 'to_many_through_sql_cross_table' || sortedAssociations[i].type === 'generic_to_many' ){-%>

    //search
    var s = getSearchArgument('<%- sortedAssociations[i].targetModelLc _%>', searchText, ops);

    //pagination
    var p = `pagination: {offset: ${paginationOffset}, limit: ${paginationLimit}}`

    var query = (s) ?
      `{ readOne<%- nameCp %>(<%- internalId _%>:<%_ if(internalIdType === 'String') {-%> "${itemId}" <%_}else {-%> ${itemId} <%_}-%>) {
        <%- sortedAssociations[i].relationNameLc _%>Filter( ${s}, ${p} ) {
<%if(sortedAssociations[i].isDefaultId){-%>
          <%- internalId _%>,
<%}-%>
<%_for( let j=0; j<modelsAtts[sortedAssociations[i].targetModel].length; j++ ){-%>
          <%- modelsAtts[sortedAssociations[i].targetModel][j][0] -%>,
<%}-%>
        },
        countFiltered<%- sortedAssociations[i].relationNameCp %>( ${s} )
      } }` :
      `{ readOne<%- nameCp %>(<%- internalId _%>:<%_ if(internalIdType === 'String') {-%> "${itemId}" <%_}else {-%> ${itemId} <%_}-%>) {
        <%- sortedAssociations[i].relationNameLc _%>Filter( ${p} ) {
<%if(sortedAssociations[i].isDefaultId){-%>
          <%- internalId _%>,
<%}-%>
<%_for( let j=0; j<modelsAtts[sortedAssociations[i].targetModel].length; j++ ){-%>
          <%- modelsAtts[sortedAssociations[i].targetModel][j][0] -%>,
<%}-%>
        },
        countFiltered<%- sortedAssociations[i].relationNameCp %>
      } }`;
<%} else {-%>
<%
  /**
   * to_one
   * generic_to_one
   */
-%>
    var query = 
      `{ readOne<%- nameCp %>(<%- internalId _%>:<%_ if(internalIdType === 'String') {-%> "${itemId}" <%_}else {-%> ${itemId} <%_}-%>) { 
        <%- sortedAssociations[i].relationName _%> { 
<%if(sortedAssociations[i].isDefaultId){-%>
          <%- internalId _%>,
<%}-%>
<%_for( let j=0; j<modelsAtts[sortedAssociations[i].targetModel].length; j++ ){-%>
          <%- modelsAtts[sortedAssociations[i].targetModel][j][0] -%>,
<%}-%>
      } } }`;
<%}-%>

    /**
     * Debug
     */
    console.log("getAssociationFilter.query: gql:\n", query);

    return requestGraphql({ url, query });
  },
<%} else if(sortedAssociations[i].paginationType === 'cursorBased') {-%>
<%
  /**
   * cursorBased
   */
-%>
  /**
   * get<%- sortedAssociations[i].relationNameCp %>Connection
   *
   * Get <%- sortedAssociations[i].targetModelPlLc %> connection (cursor based) records associated to the given <%- nameLc %> record
   * through association '<%- sortedAssociations[i].relationNameCp %>', from GraphQL Server.
   *
   *
   * @param {String} url GraphQL Server url
   * @param {Number} itemId Model item internalId.
   * @param {String} label Label name.
   * @param {String} sublabel Sublabel name.
   * @param {String} searchText Text string currently on search bar.
   * @param {Object} variables Object with cursor-based-pagination variables.
   * @param {String} ops Object with adittional query options.
   */
  get<%- sortedAssociations[i].relationNameCp %>Connection(url, itemId, label, sublabel, searchText, variables, ops) {
<%_if( sortedAssociations[i].type === 'to_many' || sortedAssociations[i].type === 'to_many_through_sql_cross_table' || sortedAssociations[i].type === 'generic_to_many' ){-%>
<%
  /**
   * to_many
   * to_many_through_sql_cross_table
   * generic_to_many
   */
-%>
    //search
    var s = getSearchArgument('<%- sortedAssociations[i].targetModelLc _%>', searchText, ops);

    var qbody = `
          pageInfo {
            startCursor
            endCursor
            hasPreviousPage
            hasNextPage
          },
          edges {
            node {
<%if(sortedAssociations[i].isDefaultId){-%>
              <%- internalId _%>,
<%}-%>
<%_for( let j=0; j<modelsAtts[sortedAssociations[i].targetModel].length; j++ ){-%>
              <%- modelsAtts[sortedAssociations[i].targetModel][j][0] -%>,
<%}-%>
            }
          }`

    var query = (s) ?
      `query readOne<%- nameCp %>($pagination: paginationCursorInput) {
        readOne<%- nameCp %>(<%- internalId _%>:<%_ if(internalIdType === 'String') {-%> "${itemId}" <%_}else {-%> ${itemId} <%_}-%>) {
          <%- sortedAssociations[i].relationNameLc _%>Connection( ${s}, pagination: $pagination ) {
            ${qbody},
          },
          countFiltered<%- sortedAssociations[i].relationNameCp %>( ${s} )
      } }` :
      `query readOne<%- nameCp %>($pagination: paginationCursorInput) {
        readOne<%- nameCp %>(<%- internalId _%>:<%_ if(internalIdType === 'String') {-%> "${itemId}" <%_}else {-%> ${itemId} <%_}-%>) {
          <%- sortedAssociations[i].relationNameLc _%>Connection( pagination: $pagination ) {
            ${qbody},
          },
          countFiltered<%- sortedAssociations[i].relationNameCp %>
      } }`;
<%} else {-%>
<%
  /**
   * to_one
   * generic_to_one
   */
-%>
    var query = 
      `{ readOne<%- nameCp %>(<%- internalId _%>:<%_ if(internalIdType === 'String') {-%> "${itemId}" <%_}else {-%> ${itemId} <%_}-%>) { 
        <%- sortedAssociations[i].relationName _%> { 
<%if(sortedAssociations[i].isDefaultId){-%>
          <%- internalId _%>,
<%}-%>
<%_for( let j=0; j<modelsAtts[sortedAssociations[i].targetModel].length; j++ ){-%>
          <%- modelsAtts[sortedAssociations[i].targetModel][j][0] -%>,
<%}-%>
      } } }`;
<%}-%>

    /**
     * Debug
     */
    console.log("getAssociationFilter.query: gql:\n", query);
    console.log("getAssociationFilter.variables: gql:\n", variables);

    return requestGraphql({ url, query, variables });
  },
<%}-%>
<%
  /**
   * Filters
   * 
   * association types:
   *   - to_many
   *   - to_many_through_sql_cross_table
   *   - generic_to_many
   * 
   * limitOffset:
   *   - get<AssociatedModel>FilterCount
   * 
   * cursorBased:
   *   - get<AssociatedModel>ConnectionCount
   */
-%>
<%_if( sortedAssociations[i].type === 'to_many' || sortedAssociations[i].type === 'to_many_through_sql_cross_table' || sortedAssociations[i].type === 'generic_to_many' ){-%>
<%
  /**
   * to_many
   * to_many_through_sql_cross_table
   * generic_to_many
   */
-%>
<%
  /**
   * limitOffset
   */
-%>
<%if(sortedAssociations[i].paginationType === 'limitOffset') {-%>
  /**
   * get<%- sortedAssociations[i].relationNameCp %>FilterCount
   * 
   * Get <%- sortedAssociations[i].targetModelPlLc %> filter records count associated to the given <%- nameLc %> record
   * through association '<%- sortedAssociations[i].relationNameCp %>', from GraphQL Server.
   * 
   * 
   * @param {String} url GraphQL Server url
   * @param {Number} itemId Model item internalId.
   * @param {String} searchText Text string currently on search bar.
   * @param {String} ops Object with adittional query options.
   */
  get<%- sortedAssociations[i].relationNameCp %>FilterCount(url, itemId, searchText, ops) {
    //search
    var s = getSearchArgument('<%- sortedAssociations[i].targetModelLc _%>', searchText, ops); 

    var query = (s) ?
      `{ readOne<%- nameCp %>(<%- internalId _%>:<%_ if(internalIdType === 'String') {-%> "${itemId}" <%_}else {-%> ${itemId} <%_}-%>) { 
        countFiltered<%- sortedAssociations[i].relationNameCp %>( ${s} ) 
      } }` :      
      `{ readOne<%- nameCp %>(<%- internalId _%>:<%_ if(internalIdType === 'String') {-%> "${itemId}" <%_}else {-%> ${itemId} <%_}-%>) {  
        countFiltered<%- sortedAssociations[i].relationNameCp %> 
      } }`;

    /**
     * Debug
     */
    console.log("getAssociationFilterCount.query: gql:\n", query);

    return requestGraphql({ url, query });
  },
<%} else if(sortedAssociations[i].paginationType === 'cursorBased') {-%>
<%
  /**
   * cursorBased
   */
-%>
  /**
   * get<%- sortedAssociations[i].relationNameCp %>ConnectionCount
   * 
   * Get <%- sortedAssociations[i].targetModelPlLc %> Connection (cursor based) records count associated to the given <%- nameLc %> record
   * through association '<%- sortedAssociations[i].relationNameCp %>', from GraphQL Server.
   * 
   * 
   * @param {String} url GraphQL Server url
   * @param {Number} itemId Model item internalId.
   * @param {String} searchText Text string currently on search bar.
   * @param {String} ops Object with adittional query options.
   */
  get<%- sortedAssociations[i].relationNameCp %>ConnectionCount(url, itemId, searchText, ops) {
    //search
    var s = getSearchArgument('<%- sortedAssociations[i].targetModelLc _%>', searchText, ops); 

    var query = (s) ?
      `query {
        readOne<%- nameCp %>(<%- internalId _%>:<%_ if(internalIdType === 'String') {-%> "${itemId}" <%_}else {-%> ${itemId} <%_}-%>) { 
          countFiltered<%- sortedAssociations[i].relationNameCp %>( ${s} ) 
      } }` :      
      `query {
        readOne<%- nameCp %>(<%- internalId _%>:<%_ if(internalIdType === 'String') {-%> "${itemId}" <%_}else {-%> ${itemId} <%_}-%>) { 
          countFiltered<%- sortedAssociations[i].relationNameCp %> 
      } }`;

    /**
     * Debug
     */
    console.log("getAssociationConnectionCount.query: gql:\n", query);

    return requestGraphql({ url, query });
  },
<%}-%>
<%}-%>
<%
  /**
   * Filters: associated ids
   * 
   */
-%>
<%if(sortedAssociations[i].paginationType === 'limitOffset') {-%>
  /**
   *
   *
   * getAssociated<%- sortedAssociations[i].relationNameCp %>
   *
   * Get the <%- sortedAssociations[i].targetModelLc %>-ids associated to the given <%- nameLc %> record
   * through association '<%- sortedAssociations[i].relationNameCp %>', from GraphQL Server.
   *
   * @param {String} url GraphQL Server url
   * @param {Number} itemId Model item internalId.
   */
  getAssociated<%- sortedAssociations[i].relationNameCp _%>(url, itemId) {
<%_if( sortedAssociations[i].type === 'to_many' || sortedAssociations[i].type === 'to_many_through_sql_cross_table' || sortedAssociations[i].type === 'generic_to_many' ){-%>
    var query =
    `{ readOne<%- nameCp %>( <%- internalId _%>: <%_ if(internalIdType === 'String') {-%> "${itemId}" <%_}else {-%> ${itemId} <%_}-%> ){
      <%- sortedAssociations[i].relationNameLc _%>Filter{ <%- sortedAssociations[i].internalId -%> } } }`;
<%} else {-%>
    var query =
    `{ readOne<%- nameCp %>( <%- internalId _%>: <%_ if(internalIdType === 'String') {-%> "${itemId}" <%_}else {-%> ${itemId} <%_}-%> ){
      <%- sortedAssociations[i].relationName _%>{ <%- sortedAssociations[i].internalId -%> } } }`;
<%}-%>
    /**
     * Debug
     */
    console.log("getAssociatedIds.query: gql:\n", query);

    return requestGraphql({ url, query });
  },
<%} else if(sortedAssociations[i].paginationType === 'cursorBased') {-%>
  /**
   *
   *
   * getAssociated<%- sortedAssociations[i].relationNameCp %>Connection
   *
   * Get the <%- sortedAssociations[i].targetModelLc %>-ids associated (by cursor based connection) to the given <%- nameLc %> record
   * through association '<%- sortedAssociations[i].relationNameCp %>', from GraphQL Server.
   *
   * @param {String} url GraphQL Server url
   * @param {Number} itemId Model item internalId.
   */
  getAssociated<%- sortedAssociations[i].relationNameCp _%>Connection(url, itemId) {
<%_if( sortedAssociations[i].type === 'to_many' || sortedAssociations[i].type === 'to_many_through_sql_cross_table' || sortedAssociations[i].type === 'generic_to_many' ){-%>
    var query =
      `{ readOne<%- nameCp %>( <%- internalId _%>: <%_ if(internalIdType === 'String') {-%> "${itemId}" <%_}else {-%> ${itemId} <%_}-%> ){
        <%- sortedAssociations[i].relationNameLc _%>Connection{ edges { node { <%- sortedAssociations[i].internalId -%> } } } } }`;
<%} else {-%>
    var query =
    `{ readOne<%- nameCp %>( <%- internalId _%>: <%_ if(internalIdType === 'String') {-%> "${itemId}" <%_}else {-%> ${itemId} <%_}-%> ){
      <%- sortedAssociations[i].relationName _%>{ <%- sortedAssociations[i].internalId -%> } } }`;
<%}-%>
    /**
     * Debug
     */
    console.log("getAssociatedIds.query: gql:\n", query);

    return requestGraphql({ url, query });
  },
<%}-%>
<%#
  /**
   * Filters: 
   *   - not associated items count
   */
-%>
 /**
   * getNotAssociated<%- sortedAssociations[i].relationNameCp %>Count
   *
   * Get count of not associated <%- sortedAssociations[i].relationNameCp %> from GraphQL Server.
   *
   * @param {String} url GraphQL Server url
   * @param {String} searchText Text string currently on search bar.
   * @param {String} itemId Model item internalId.
   * @param {String} ops Object with adittional query options.
   */
  async getNotAssociated<%- sortedAssociations[i].relationNameCp %>Count(url, searchText, itemId, ops) {
    let graphqlErrors = [];
<%#
  /**
   * to_one
   * generic_to_one
   */
-%>
<%_if( sortedAssociations[i].type === 'to_one' || sortedAssociations[i].type === 'generic_to_one' ){-%>
    let query = '';
    //get ands search filters
    let ands = getSearchArgument('<%- sortedAssociations[i].targetModelLc _%>', searchText, ops, 'ands');

    //get associated item
    let associatedItem = null;
<%if(sortedAssociations[i].paginationType === 'limitOffset') {-%>
    let response = await this.getAssociated<%- sortedAssociations[i].relationNameCp _%>(url, itemId);
<%} else if(sortedAssociations[aindex].paginationType === 'cursorBased') {-%>
    let response = await this.getAssociated<%- sortedAssociations[i].relationNameCp _%>Connection(url, itemId);  
<%}-%>
    //check
    let check = checkResponse(response, graphqlErrors, "readOne<%- nameCp _%>");
    if(check === 'ok') {
      if( response.data.data["readOne<%- nameCp _%>"] ){
          //check types
          if(typeof response.data.data["readOne<%- nameCp _%>"] !== 'object'
          || typeof response.data.data["readOne<%- nameCp _%>"]["<%- sortedAssociations[i].relationName _%>"] !== 'object' //can be null
          ) return {data: response.data.data, value: null, message: 'bad_type', graphqlErrors: (graphqlErrors.length>0) ? graphqlErrors : undefined};
          
          //get value
          associatedItem = response.data.data["readOne<%- nameCp _%>"]["<%- sortedAssociations[i].relationName _%>"];
          //ok

        } else return {data: response.data.data, value: null, message: 'bad_format', graphqlErrors: (graphqlErrors.length>0) ? graphqlErrors : undefined};
    } else return {data: response.data.data, value: null, message: check, graphqlErrors: (graphqlErrors.length>0) ? graphqlErrors : undefined};

    /**
     * Case: has associated item
     */
    if(associatedItem) {
      //make filter to exclude associated item & include null's
      let f1 = `{field: <%- sortedAssociations[i].internalId _%>, valueType: <%- sortedAssociations[i].internalIdType _%>, value: "${associatedItem.<%- sortedAssociations[i].internalId _%>}", operator: ne}`;
      let f2 = `{field: <%- sortedAssociations[i].internalId _%>, valueType: <%- sortedAssociations[i].internalIdType _%>, value: null, operator: eq}`;
      let nf = `{operator: or, search: [ ${f1}, ${f2} ]}`;

      //add new filter to ands
      ands += nf;

      //make search
      let s = `search: {operator:and, search: [ ${ands} ]}`;
      //set query
      query = `{ count<%- sortedAssociations[i].targetModelPlCp _%>(${s}) }`;
      
    } else {
      /**
       * Case: has not associated item
       */
      if(ands !== '') {
        let s = `search: {operator:and, search: [ ${ands} ]}`;
        query = `{ count<%- sortedAssociations[i].targetModelPlCp _%>(${s}) }`;
      }
      else {
        query = `{ count<%- sortedAssociations[i].targetModelPlCp _%> }`;
      }
    }

    /**
     * Debug
     */
    console.log("getNotAssociated<%- sortedAssociations[i].relationNameCp %>Count.query: gql:\n", query);

    response = await requestGraphql({ url, query });
    //check
    check = checkResponse(response, graphqlErrors, "count<%- sortedAssociations[i].targetModelPlCp _%>");
    if(check === 'ok') {
      if( response.data.data["count<%- sortedAssociations[i].targetModelPlCp _%>"] !== undefined ) {
        //check type
        if(!Number.isInteger(response.data.data["count<%- sortedAssociations[i].targetModelPlCp _%>"])) 
        return {data: response.data.data, value: null, message: 'bad_type', graphqlErrors: (graphqlErrors.length>0) ? graphqlErrors : undefined};

        //get value
        let count = response.data.data["count<%- sortedAssociations[i].targetModelPlCp _%>"];
        //ok
        return {value: count, message: 'ok', graphqlErrors: (graphqlErrors.length>0) ? graphqlErrors : undefined};

      } else return {data: response.data.data, value: null, message: 'bad_format', graphqlErrors: (graphqlErrors.length>0) ? graphqlErrors : undefined};
    } else return {data: response.data.data, value: null, message: check, graphqlErrors: (graphqlErrors.length>0) ? graphqlErrors : undefined};
<%}-%>
<%
  /**
   * to_many
   * generic_to_many
   */
-%>
<%_if( sortedAssociations[i].type === 'to_many' || sortedAssociations[i].type === 'generic_to_many' ){-%>
    let query = '';
    //get ands search filters
    let ands = getSearchArgument('<%- sortedAssociations[i].targetModelLc _%>', searchText, ops, 'ands');
  
    //make filter to exclude itemId on FK & include null's
    let f1 = `{field: <%- sortedAssociations[i].targetKey _%>, valueType: <%- internalIdType _%>, value: "${itemId}", operator: ne}`;
    let f2 = `{field: <%- sortedAssociations[i].targetKey _%>, valueType: <%- internalIdType _%>, value: null, operator: eq}`;
    let nf = `{operator: or, search: [ ${f1}, ${f2} ]}`;

    //add new filter to ands
    ands += nf;

    //make search
    let s = `search: {operator:and, search: [ ${ands} ]}`;
    //set query
    query = `{ count<%- sortedAssociations[i].targetModelPlCp _%>(${s}) }`;

    /**
     * Debug
     */
    console.log("getNotAssociated<%- sortedAssociations[i].relationNameCp %>Count.query: gql:\n", query);

    let response = await requestGraphql({ url, query });
    //check
    let check = checkResponse(response, graphqlErrors, "count<%- sortedAssociations[i].targetModelPlCp _%>");
    if(check === 'ok') {
      if( response.data.data["count<%- sortedAssociations[i].targetModelPlCp _%>"] !== undefined ) {
        //check type
        if(!Number.isInteger(response.data.data["count<%- sortedAssociations[i].targetModelPlCp _%>"])) 
        return {data: response.data.data, value: null, message: 'bad_type', graphqlErrors: (graphqlErrors.length>0) ? graphqlErrors : undefined};

        //get value
        let count = response.data.data["count<%- sortedAssociations[i].targetModelPlCp _%>"];
        //ok
        return {value: count, message: 'ok', graphqlErrors: (graphqlErrors.length>0) ? graphqlErrors : undefined};

      } else return {data: response.data.data, value: null, message: 'bad_format', graphqlErrors: (graphqlErrors.length>0) ? graphqlErrors : undefined};
    } else return {data: response.data.data, value: null, message: check, graphqlErrors: (graphqlErrors.length>0) ? graphqlErrors : undefined};
<%}-%>
<%
  /**
   * to_many_through_sql_cross_table
   */
-%>
<%_if( sortedAssociations[i].type === 'to_many_through_sql_cross_table' ){-%>
    let query = '';
    //get search filters
    let s = getSearchArgument('<%- sortedAssociations[i].targetModelLc _%>', searchText, ops);
    if(s) {
      query = `{ count<%- sortedAssociations[i].targetModelPlCp _%>(${s}) }`;
    }
    else {
      query = `{ count<%- sortedAssociations[i].targetModelPlCp _%> }`;
    }

    /**
     * Debug
     */
    console.log("getNotAssociated<%- sortedAssociations[i].relationNameCp %>Count.query: gql:\n", query);
    
    //get total items count
    let totalCount = null;
    let response = await requestGraphql({ url, query });
    //check
    let check = checkResponse(response, graphqlErrors, "count<%- sortedAssociations[i].targetModelPlCp _%>");
    if(check === 'ok') {
      if( response.data.data["count<%- sortedAssociations[i].targetModelPlCp _%>"] !== undefined ) {
        //check type
        if(!Number.isInteger(response.data.data["count<%- sortedAssociations[i].targetModelPlCp _%>"])) 
        return {data: response.data.data, value: null, message: 'bad_type', graphqlErrors: (graphqlErrors.length>0) ? graphqlErrors : undefined};

        //get value
        totalCount = response.data.data["count<%- sortedAssociations[i].targetModelPlCp _%>"];
        //ok

      } else return {data: response.data.data, value: null, message: 'bad_format', graphqlErrors: (graphqlErrors.length>0) ? graphqlErrors : undefined};
    } else return {data: response.data.data, value: null, message: check, graphqlErrors: (graphqlErrors.length>0) ? graphqlErrors : undefined};

    //get associated items count
    let associatedCount = null;
<%if(sortedAssociations[i].paginationType === 'limitOffset') {-%>
    response = await this.get<%- sortedAssociations[i].relationNameCp _%>FilterCount(url, itemId, searchText, ops);
<%} else if(sortedAssociations[aindex].paginationType === 'cursorBased') {-%>
    response = await this.get<%- sortedAssociations[i].relationNameCp _%>ConnectionCount(url, itemId, searchText, ops);
<%}-%>
    //check
    check = checkResponse(response, graphqlErrors, "readOne<%- nameCp _%>");
    if(check === 'ok') {
      if( response.data.data["readOne<%- nameCp _%>"] ){
          //check types
          if(typeof response.data.data["readOne<%- nameCp _%>"] !== 'object'
          || !Number.isInteger(response.data.data["readOne<%- nameCp _%>"]["countFiltered<%- sortedAssociations[i].relationNameCp _%>"])
          ) return {data: response.data.data, value: null, message: 'bad_type', graphqlErrors: (graphqlErrors.length>0) ? graphqlErrors : undefined};
          
          //get value
          associatedCount = response.data.data["readOne<%- nameCp _%>"]["countFiltered<%- sortedAssociations[i].relationNameCp _%>"];

          /**
           * Debug
           */
          console.log("total-<%- sortedAssociations[i].targetModelPlCp _%>:", totalCount);
          console.log("total-associated-<%- sortedAssociations[i].targetModelPlCp _%>:", associatedCount);

          //ok
          return {value: (totalCount - associatedCount), message: 'ok', graphqlErrors: (graphqlErrors.length>0) ? graphqlErrors : undefined};

        } else return {data: response.data.data, value: null, message: 'bad_format', graphqlErrors: (graphqlErrors.length>0) ? graphqlErrors : undefined};
    } else return {data: response.data.data, value: null, message: check, graphqlErrors: (graphqlErrors.length>0) ? graphqlErrors : undefined}
<%}-%>
  },
<%#
  /**
   * Filters: 
   *   - not associated items
   */
-%>
 /**
   * getNotAssociated<%- sortedAssociations[i].relationNameCp %>
   *
<%if(sortedAssociations[i].paginationType === 'limitOffset') {-%>
   * Get not associated <%- sortedAssociations[i].relationNameCp %> items from GraphQL Server.
   *
   * @param {String} url GraphQL Server url
   * @param {String} searchText Text string currently on search bar.
   * @param {String} orderBy Order field string.
   * @param {String} orderDirection Text string: asc | desc.
   * @param {Number} paginationOffset Offset.
   * @param {Number} paginationLimit Max number of items to retreive.
   * @param {String} itemId Model item internalId.
   * @param {String} ops Object with adittional query options.
   * @param {Int}    batchSize Max number of records to fetch in batch from GraphQL Server.
   */
  async getNotAssociated<%- sortedAssociations[i].relationNameCp %>(url, searchText, orderBy, orderDirection, paginationOffset, paginationLimit, itemId, ops, batchSize) {
<%}-%>
<%if(sortedAssociations[i].paginationType === 'cursorBased') {-%>
   * Get not associated <%- sortedAssociations[i].relationNameCp %> items from GraphQL Server using a cursor-based-connection.
   *
   * @param {String} url GraphQL Server url
   * @param {String} searchText Text string currently on search bar.
   * @param {String} orderBy Order field string.
   * @param {String} orderDirection Text string: asc | desc.
   * @param {Object} variables Object with cursor-based-pagination variables.
   * @param {String} itemId Model item internalId.
   * @param {String} ops Object with additional query options.
   * @param {Int}    batchSize Max number of records to fetch in batch from GraphQL Server.
   */
  async getNotAssociated<%- sortedAssociations[i].relationNameCp %>(url, searchText, orderBy, orderDirection, variables, itemId, ops, batchSize) {
<%}-%>
    let graphqlErrors = [];
    let attributes = getAttributes('<%- sortedAssociations[i].targetModelLc _%>');
    //query attributes
    let qattributes = Object.keys(attributes).join();
<%#
  /**
   * to_one
   * generic_to_one
   */
-%>
<%_if( sortedAssociations[i].type === 'to_one' || sortedAssociations[i].type === 'generic_to_one' ){-%>
    let query = '';
    //get ands search filters
    let ands = getSearchArgument('<%- sortedAssociations[i].targetModelLc _%>', searchText, ops, 'ands');

    //get associated items
    let associatedItem = null;
<%if(sortedAssociations[i].paginationType === 'limitOffset') {-%>
    let response = await this.getAssociated<%- sortedAssociations[i].relationNameCp _%>(url, itemId);
<%} else if(sortedAssociations[aindex].paginationType === 'cursorBased') {-%>
    let response = await this.getAssociated<%- sortedAssociations[i].relationNameCp _%>Connection(url, itemId);  
<%}-%>
    //check
    let check = checkResponse(response, graphqlErrors, "readOne<%- nameCp _%>");
    if(check === 'ok') {
      if( response.data.data["readOne<%- nameCp _%>"] ){
          //check types
          if(typeof response.data.data["readOne<%- nameCp _%>"] !== 'object'
          || typeof response.data.data["readOne<%- nameCp _%>"]["<%- sortedAssociations[i].relationName _%>"] !== 'object' //can be null
          ) return {data: response.data.data, value: null, message: 'bad_type', graphqlErrors: (graphqlErrors.length>0) ? graphqlErrors : undefined};
          
          //get value
          associatedItem = response.data.data["readOne<%- nameCp _%>"]["<%- sortedAssociations[i].relationName _%>"];
          //ok

        } else return {data: response.data.data, value: null, message: 'bad_format', graphqlErrors: (graphqlErrors.length>0) ? graphqlErrors : undefined};
    } else return {data: response.data.data, value: null, message: check, graphqlErrors: (graphqlErrors.length>0) ? graphqlErrors : undefined};

<%if(sortedAssociations[i].paginationType === 'limitOffset') {-%>
    let p = `pagination: {offset: ${paginationOffset}, limit: ${paginationLimit}}`;
<%} else if(sortedAssociations[aindex].paginationType === 'cursorBased') {-%>
    let qbody = 
      `pageInfo {
          startCursor
          endCursor
          hasPreviousPage
          hasNextPage
        }
        edges {
          node {
            ${qattributes}
          }
        }`;
<%}-%>   

    /**
     * Case: has associated item
     */
    if(associatedItem) {
      //make filter to exclude associated item & include null's
      let f1 = `{field: <%- sortedAssociations[i].internalId _%>, valueType: <%- sortedAssociations[i].internalIdType _%>, value: "${associatedItem.<%- sortedAssociations[i].internalId _%>}", operator: ne}`;
      let f2 = `{field: <%- sortedAssociations[i].internalId _%>, valueType: <%- sortedAssociations[i].internalIdType _%>, value: null, operator: eq}`;
      let nf = `{operator: or, search: [ ${f1}, ${f2} ]}`;

      //add new filter to ands
      ands += nf;
    }

    if(ands !== '') {
      let s = `search: {operator:and, search: [ ${ands} ]}`;
<%if(sortedAssociations[i].paginationType === 'limitOffset') {-%>
      query = `{ <%- sortedAssociations[i].targetModelPlLc _%>( ${s}, ${p} ) { ${qattributes} }}`;
<%} else if(sortedAssociations[aindex].paginationType === 'cursorBased') {-%>
      query =
        `query <%- sortedAssociations[i].targetModelPlLc _%>Connection($pagination: paginationCursorInput)
          { <%- sortedAssociations[i].targetModelPlLc _%>Connection( ${s}, pagination: $pagination ) {
            ${qbody}
          }}`;
<%}-%>
    } else {
<%if(sortedAssociations[i].paginationType === 'limitOffset') {-%>
      query = `{ <%- sortedAssociations[i].targetModelPlLc _%>( ${p} ) { ${qattributes} }}`;
<%} else if(sortedAssociations[aindex].paginationType === 'cursorBased') {-%>
      query =
        `query <%- sortedAssociations[i].targetModelPlLc _%>Connection($pagination: paginationCursorInput)
          { <%- sortedAssociations[i].targetModelPlLc _%>Connection( pagination: $pagination ) {
            ${qbody}
          }}`;
<%}-%>
    }

    /**
     * Debug
     */
    console.log("getNotAssociated<%- sortedAssociations[i].relationNameCp %>.query: gql:\n", query);

<%if(sortedAssociations[i].paginationType === 'limitOffset') {-%>
    response = await requestGraphql({ url, query });
    //check
    check = checkResponse(response, graphqlErrors, "<%- sortedAssociations[i].targetModelPlLc _%>");
    if(check === 'ok') {
      if( response.data.data["<%- sortedAssociations[i].targetModelPlLc _%>"] ) {
        //check type
        if(!Array.isArray(response.data.data["<%- sortedAssociations[i].targetModelPlLc _%>"])) 
        return {data: response.data.data, value: null, message: 'bad_type', graphqlErrors: (graphqlErrors.length>0) ? graphqlErrors : undefined};

        //get value
        let items = response.data.data["<%- sortedAssociations[i].targetModelPlLc _%>"];
        //ok
        return {value: items, message: 'ok', graphqlErrors: (graphqlErrors.length>0) ? graphqlErrors : undefined};

      } else return {data: response.data.data, value: null, message: 'bad_format', graphqlErrors: (graphqlErrors.length>0) ? graphqlErrors : undefined};
    } else return {data: response.data.data, value: null, message: check, graphqlErrors: (graphqlErrors.length>0) ? graphqlErrors : undefined};
<%} else if(sortedAssociations[aindex].paginationType === 'cursorBased') {-%>
    response = await requestGraphql({ url, query });
    //check
    check = checkResponse(response, graphqlErrors, "<%- sortedAssociations[i].targetModelPlLc _%>Connection");
    if(check === 'ok') {
      if( response.data.data["<%- sortedAssociations[i].targetModelPlLc _%>Connection"] ) {
        //check type
        if(typeof response.data.data["<%- sortedAssociations[i].targetModelPlLc _%>Connection"] !== 'object'
        || !Array.isArray(response.data.data["<%- sortedAssociations[i].targetModelPlLc _%>Connection"].edges)
        || typeof response.data.data["<%- sortedAssociations[i].targetModelPlLc _%>Connection"].pageInfo !== 'object' 
        || response.data.data["<%- sortedAssociations[i].targetModelPlLc _%>Connection"].pageInfo === null)
        return {data: response.data.data, value: null, message: 'bad_type', graphqlErrors: (graphqlErrors.length>0) ? graphqlErrors : undefined};

        //get value
        let connection = response.data.data["<%- sortedAssociations[i].targetModelPlLc _%>Connection"];
        //ok
        return {value: connection, message: 'ok', graphqlErrors: (graphqlErrors.length>0) ? graphqlErrors : undefined};

      } else return {data: response.data.data, value: null, message: 'bad_format', graphqlErrors: (graphqlErrors.length>0) ? graphqlErrors : undefined};
    } else return {data: response.data.data, value: null, message: check, graphqlErrors: (graphqlErrors.length>0) ? graphqlErrors : undefined};
<%}-%>
<%}-%>
<%
  /**
   * to_many
   * generic_to_many
   */
-%>
<%_if( sortedAssociations[i].type === 'to_many' || sortedAssociations[i].type === 'generic_to_many' ){-%>
    let query = '';
    //get ands search filters
    let ands = getSearchArgument('<%- sortedAssociations[i].targetModelLc _%>', searchText, ops, 'ands');
  
    //make filter to exclude itemId on FK & include null's
    let f1 = `{field: <%- sortedAssociations[i].targetKey _%>, valueType: <%- internalIdType _%>, value: "${itemId}", operator: ne}`;
    let f2 = `{field: <%- sortedAssociations[i].targetKey _%>, valueType: <%- internalIdType _%>, value: null, operator: eq}`;
    let nf = `{operator: or, search: [ ${f1}, ${f2} ]}`;

    //add new filter to ands
    ands += nf;

<%if(sortedAssociations[i].paginationType === 'limitOffset') {-%>
    let p = `pagination: {offset: ${paginationOffset}, limit: ${paginationLimit}}`;
<%} else if(sortedAssociations[aindex].paginationType === 'cursorBased') {-%>
    let qbody = 
      `pageInfo {
          startCursor
          endCursor
          hasPreviousPage
          hasNextPage
        }
        edges {
          node {
            ${qattributes}
          }
        }`;
<%}-%> 

    //make search
    let s = `search: {operator:and, search: [ ${ands} ]}`;
<%if(sortedAssociations[i].paginationType === 'limitOffset') {-%>
      query = `{ <%- sortedAssociations[i].targetModelPlLc _%>( ${s}, ${p} ) { ${qattributes} }}`;
<%} else if(sortedAssociations[aindex].paginationType === 'cursorBased') {-%>
      query =
        `query <%- sortedAssociations[i].targetModelPlLc _%>Connection($pagination: paginationCursorInput)
          { <%- sortedAssociations[i].targetModelPlLc _%>Connection( ${s}, pagination: $pagination ) {
            ${qbody}
          }}`;
<%}-%>

    /**
     * Debug
     */
    console.log("getNotAssociated<%- sortedAssociations[i].relationNameCp %>.query: gql:\n", query);

<%if(sortedAssociations[i].paginationType === 'limitOffset') {-%>
    let response = await requestGraphql({ url, query });
    //check
    let check = checkResponse(response, graphqlErrors, "<%- sortedAssociations[i].targetModelPlLc _%>");
    if(check === 'ok') {
      if( response.data.data["<%- sortedAssociations[i].targetModelPlLc _%>"] ) {
        //check type
        if(!Array.isArray(response.data.data["<%- sortedAssociations[i].targetModelPlLc _%>"])) 
        return {data: response.data.data, value: null, message: 'bad_type', graphqlErrors: (graphqlErrors.length>0) ? graphqlErrors : undefined};

        //get value
        let items = response.data.data["<%- sortedAssociations[i].targetModelPlLc _%>"];
        //ok
        return {value: items, message: 'ok', graphqlErrors: (graphqlErrors.length>0) ? graphqlErrors : undefined};

      } else return {data: response.data.data, value: null, message: 'bad_format', graphqlErrors: (graphqlErrors.length>0) ? graphqlErrors : undefined};
    } else return {data: response.data.data, value: null, message: check, graphqlErrors: (graphqlErrors.length>0) ? graphqlErrors : undefined};
<%} else if(sortedAssociations[aindex].paginationType === 'cursorBased') {-%>
    let response = await requestGraphql({ url, query });
    //check
    let check = checkResponse(response, graphqlErrors, "<%- sortedAssociations[i].targetModelPlLc _%>Connection");
    if(check === 'ok') {
      if( response.data.data["<%- sortedAssociations[i].targetModelPlLc _%>Connection"] ) {
        //check type
        if(typeof response.data.data["<%- sortedAssociations[i].targetModelPlLc _%>Connection"] !== 'object'
        || !Array.isArray(response.data.data["<%- sortedAssociations[i].targetModelPlLc _%>Connection"].edges)
        || typeof response.data.data["<%- sortedAssociations[i].targetModelPlLc _%>Connection"].pageInfo !== 'object' 
        || response.data.data["<%- sortedAssociations[i].targetModelPlLc _%>Connection"].pageInfo === null)
        return {data: response.data.data, value: null, message: 'bad_type', graphqlErrors: (graphqlErrors.length>0) ? graphqlErrors : undefined};

        //get value
        let connection = response.data.data["<%- sortedAssociations[i].targetModelPlLc _%>Connection"];
        //ok
        return {value: connection, message: 'ok', graphqlErrors: (graphqlErrors.length>0) ? graphqlErrors : undefined};

      } else return {data: response.data.data, value: null, message: 'bad_format', graphqlErrors: (graphqlErrors.length>0) ? graphqlErrors : undefined};
    } else return {data: response.data.data, value: null, message: check, graphqlErrors: (graphqlErrors.length>0) ? graphqlErrors : undefined};
<%}-%>
<%}-%>
<%
  /**
   * to_many_through_sql_cross_table
   */
-%>
<%_if( sortedAssociations[i].type === 'to_many_through_sql_cross_table' ){-%>
<%if(sortedAssociations[i].paginationType === 'limitOffset') {-%>
    /**
     * Recursive fetch of not associated items algorithm (limit-offset-pagination):
     *  1 Until @requiredItems are fetched, do:
     *    1.2 Get @requiredItems ( equal to @limit ) minus lenght.of( @notAssociatedItems already fetched) items, 
     *        where each item will be fetched with the correspondent associationFilter, which in turn will be 
     *        filtered by the current itemId. The resulting associationFilter will contain a non-empty array if
     *        the current item is associated or an empty array otherwise.
     *    1.3 Join fetched items in 1.2 with previous ones if any: in @notAssociatedItemsEdges array.
     *        Only the items with an empty array in its associationFilter will be added.
     *    1.4 Check number of items fetched:
     *        1.4.1  If: fetched items are less than the requested number of items in 1.2 and the current 
     *               result is non empty:
     *               1.4.1.1 Adjust pagination to get the next batch of items.
     *               1.4.1.2 @continue with next iteration.
     *        1.4.2  If: fetched items are equal to the requested number of items in 1.2 or the current 
     *               result is empty:
     *               1.4.2.1 Return items. 
     *               1.4.2.2 @done
     */
    //set required number of items
    // let requiredItems = paginationLimit;

    // //initialize variables to fetch the first batch of items
    // let batchPaginationOffset = paginationOffset;
    // let batchPagination = `pagination: {offset: ${batchPaginationOffset}, limit: ${batchSize}}`;
    // let batchSearch = getSearchArgument('<%- sortedAssociations[i].targetModelLc _%>', searchText, ops);
    // let batchQuery = '';
    // let nonaItems = [];

    // /**
    //  * Recursive fetch of not associated items algorithm (limit-offset-pagination):
    //  *  1 Until @requiredItems are fetched, do:
    //  * 
    //  */
    // while(nonaItems.length < requiredItems) {

    //   if(batchSearch) {
    //     batchQuery = 
    //       `{ <%- sortedAssociations[i].targetModelPlLc _%>( ${batchSearch}, ${batchPagination} ) { 
    //           ${qattributes}
    //           <%- sortedAssociations[i].peerAssociationNameLc _%>Filter(
    //             search: {field: <%- internalId _%>, value: "${itemId}", valueType: <%- internalIdType _%>, operator: eq },
    //             pagination: {limit: 1}){ <%- internalId _%> }
    //         }}`;
    //   } else {
    //     batchQuery = 
    //       `{ <%- sortedAssociations[i].targetModelPlLc _%>( ${batchPagination} ) { 
    //           ${qattributes}
    //           <%- sortedAssociations[i].peerAssociationNameLc _%>Filter(
    //             search: {field: <%- internalId _%>, value: "${itemId}", valueType: <%- internalIdType _%>, operator: eq },
    //             pagination: {limit: 1}){ <%- internalId _%> }
    //         }}`;
    //   }

    //   /**
    //    * Debug
    //    */
    //   console.log("getNotAssociated<%- sortedAssociations[i].relationNameCp %>.batchQuery: gql:\n", batchQuery);
      
    //   let batchItems = null;
    //   let response = await requestGraphql({ url, query:batchQuery });
    //   //check
    //   let check = checkResponse(response, graphqlErrors, "<%- sortedAssociations[i].targetModelPlLc _%>");
    //   if(check === 'ok') {
    //     if( response.data.data["<%- sortedAssociations[i].targetModelPlLc _%>"] ) {
    //       //check type
    //       if(!Array.isArray(response.data.data["<%- sortedAssociations[i].targetModelPlLc _%>"]))
    //       return {data: response.data.data, value: null, message: 'bad_type', graphqlErrors: (graphqlErrors.length>0) ? graphqlErrors : undefined};

    //       //get value
    //       batchItems = response.data.data["<%- sortedAssociations[i].targetModelPlLc _%>"];

    //     } else return {data: response.data.data, value: null, message: 'bad_format', graphqlErrors: (graphqlErrors.length>0) ? graphqlErrors : undefined};
    //   } else return {data: response.data.data, value: null, message: check, graphqlErrors: (graphqlErrors.length>0) ? graphqlErrors : undefined};
      

    //   /**
    //    *    1.3 Join fetched items in 1.2 with previous ones if any: in @notAssociatedItemsEdges array.
    //    *        Only the items with an empty array in its associationFilter will be added.
    //    * 
    //    */
    //   for(let i=0; (i<batchItems.length && nonaItems.length<requiredItems); i++) {
    //     if(Array.isArray(batchItems[i]["<%- sortedAssociations[i].peerAssociationNameLc _%>Filter"])
    //     && batchItems[i]["<%- sortedAssociations[i].peerAssociationNameLc _%>Filter"].length === 0) {
          
    //       //new non-associated item
    //       let it = {...batchItems[i]};
    //       //delete filter
    //       delete it["<%- sortedAssociations[i].peerAssociationNameLc _%>Filter"];
    //       //add item
    //       nonaItems.push(it);
    //     }
    //   }

    //   /**
    //    *    1.4 Check number of items fetched:
    //    *        1.4.1  If: fetched items are less than the requested number of items in 1.2 and the current 
    //    *               result is non empty:
    //    *               1.4.1.1 Adjust pagination to get the next batch of items.
    //    *               1.4.1.2 @continue with next iteration.
    //    *        1.4.2  If: fetched items are equal to the requested number of items in 1.2 or the current 
    //    *               result is empty:
    //    *               1.4.2.1 Return items. 
    //    *               1.4.2.2 @done
    //    * 
    //    */
    //   if(nonaItems.length < requiredItems && batchItems.length > 0) {
    //     //Adjust pagination to get the next batch of items.
    //     batchPaginationOffset += batchItems.length;
    //     batchPagination = `pagination: {offset: ${batchPaginationOffset}, limit: ${batchSize}}`;

    //     //continue...
    //   } else {
    //     //ok
    //     return {value: nonaItems, message: 'ok', graphqlErrors: (graphqlErrors.length>0) ? graphqlErrors : undefined};
    //   }
    }//end: while()

<%} else if(sortedAssociations[aindex].paginationType === 'cursorBased') {-%>
    // //checks
    if(!variables&&!variables.pagination&&typeof variables.pagination !== 'object' ) throw new Error("internal_error: pagination object expected");
    if(!variables.pagination.first&&!variables.pagination.last ) throw new Error("internal_error: pagination first or last positive argument expected");

    /**
     * Recursive fetch of not associated items algorithm (cursor-based-pagination):
     *  1 Until @requiredItems are fetched, do:
     *    1.2 Get @requiredItems ( equal to @first or @last ) minus lenght.of( @notAssociatedItems already fetched) items, 
     *        where each item will be fetched with the correspondent associationConnection, which in turn will be 
     *        filtered by the current itemId. The resulting associationConnection will contain a non-empty edges-array if
     *        the current item is associated or an empty edges-array otherwise.
     *    1.3 Join fetched items in 1.2 with previous ones if any: in @notAssociatedItemsEdges array.
     *        Only the items with an empty edges-array in its associationConnection will be added.
     *    1.4 Check number of fetched items:
     *        1.4.1  If: fetched items are less than the requested number of items in 1.2 and there are more items:
     *               1.4.1.1 Adjust pagination to get the next batch of items.
     *               1.4.1.2 @continue with next iteration.
     *        1.4.2  Else: fetched items are equal to the requested number of items in 1.2 or there are no more items: 
     *               1.4.2.1 Return Connection with edges and pageInfo properly configured.  
     *               1.4.2.2 @done
     */
    //set direction
    let isForward = variables.pagination.first ? true : false;
    //set required number of items
    let requiredItems = isForward ? variables.pagination.first : variables.pagination.last;

    //initialize pagination for batch query
    let batchPagination = {...variables.pagination, first: isForward ? batchSize : null, last: !isForward ? batchSize : null};
    let batchVariables = {pagination: batchPagination};
    let batchSearch = getSearchArgument('<%- sortedAssociations[i].targetModelLc _%>', searchText, ops);
    let batchQuery = '';

    let nonaPageInfo = {startCursor: null, endCursor: null, hasPreviousPage: false, hasNextPage: false};
    let nonaEdges = [];
    
     /**
     * Recursive fetch of not associated items algorithm (cursor-based-pagination):
     *  1 Until @requiredItems are fetched, do:
     * 
     */
    while(nonaEdges.length < requiredItems) {

      if(batchSearch) {
        batchQuery = 
          `query <%- sortedAssociations[i].targetModelPlLc _%>Connection($pagination: paginationCursorInput) {
            <%- sortedAssociations[i].targetModelPlLc _%>Connection(${batchSearch}, pagination: $pagination) {
              pageInfo {startCursor endCursor hasPreviousPage hasNextPage}
              edges {node {
                ${qattributes}
                <%- sortedAssociations[i].peerAssociationNameLc _%>Connection(
                  search: {field: <%- internalId _%>, value: "${itemId}", valueType: <%- internalIdType _%>, operator: eq },
                  pagination: {first: 1}){ edges {node {<%- internalId _%> }}}
            }}}}`;

      } else {
        batchQuery = 
          `query <%- sortedAssociations[i].targetModelPlLc _%>Connection($pagination: paginationCursorInput) {
            <%- sortedAssociations[i].targetModelPlLc _%>Connection(pagination: $pagination) {
              pageInfo {startCursor endCursor hasPreviousPage hasNextPage}
              edges {cursor node {
                ${qattributes}
                <%- sortedAssociations[i].peerAssociationNameLc _%>Connection(
                  search: {field: <%- internalId _%>, value: "${itemId}", valueType: <%- internalIdType _%>, operator: eq },
                  pagination: {first: 1}){ edges {node {<%- internalId _%> }}}
            }}}}`;
      }

      /**
       * Debug
       */
      console.log("getNotAssociated<%- sortedAssociations[i].relationNameCp %>.batchQuery: gql:\n", batchQuery);
      console.log("getNotAssociated<%- sortedAssociations[i].relationNameCp %>.batchVariables: gql:\n", batchVariables);
      
      /**
       *    1.2 Get @requiredItems ( equal to @first or @last ) minus lenght.of( @notAssociatedItems already fetched) items, 
       *        where each item will be fetched with the correspondent associationConnection, which in turn will be 
       *        filtered by the current itemId. The resulting associationConnection will contain a non-empty edges-array if
       *        the current item is associated or an empty edges-array otherwise.
       * 
       */
      let batchConnection = null;
      let response = await requestGraphql({ url, query:batchQuery, variables:batchVariables });
      //check
      let check = checkResponse(response, graphqlErrors, "<%- sortedAssociations[i].targetModelPlLc _%>Connection");
      if(check === 'ok') {
        if( response.data.data["<%- sortedAssociations[i].targetModelPlLc _%>Connection"] ) {
          //check type
          if(typeof response.data.data["<%- sortedAssociations[i].targetModelPlLc _%>Connection"] !== 'object'
          || !Array.isArray(response.data.data["<%- sortedAssociations[i].targetModelPlLc _%>Connection"].edges)
          || typeof response.data.data["<%- sortedAssociations[i].targetModelPlLc _%>Connection"].pageInfo !== 'object'
          || response.data.data["<%- sortedAssociations[i].targetModelPlLc _%>Connection"].pageInfo === null)
          return {data: response.data.data, value: null, message: 'bad_type', graphqlErrors: (graphqlErrors.length>0) ? graphqlErrors : undefined};

          //get value
          batchConnection = response.data.data["<%- sortedAssociations[i].targetModelPlLc _%>Connection"];

        } else return {data: response.data.data, value: null, message: 'bad_format', graphqlErrors: (graphqlErrors.length>0) ? graphqlErrors : undefined};
      } else return {data: response.data.data, value: null, message: check, graphqlErrors: (graphqlErrors.length>0) ? graphqlErrors : undefined};
      
      /**
       *    1.3 Join fetched items in 1.2 with previous ones if any: in @notAssociatedItemsEdges array.
       *        Only the items with an empty edges-array in its associationConnection will be added.
       * 
       */
      
      //get all not associated in current batch
      let batchEdges = [];
      for(let i=0; (i<batchConnection.edges.length && nonaEdges.length<requiredItems); i++) {          
          //check: not associated item
          if(batchConnection.edges[i].node["<%- sortedAssociations[i].peerAssociationNameLc _%>Connection"].edges.length === 0) {
          
            //new non-associated edge
            let edge = {...batchConnection.edges[i]};
  
            //push new edge
            batchEdges.push(edge);
          }
      }

      let thereAreMoreNonaItems = (batchEdges.length > (requiredItems - nonaEdges.length));

      //join new items
      if(batchEdges.length > 0) { //if there are new non-associated items... 
        
        //adjust pageInfo (start)
        if(nonaEdges.length === 0) {
          if(isForward) {
            nonaPageInfo.startCursor = batchEdges[0].cursor;
            nonaPageInfo.hasPreviousPage = batchConnection.pageInfo.hasPreviousPage;
          } else {
            nonaPageInfo.endCursor = batchEdges[batchEdges.length-1].cursor;
            nonaPageInfo.hasNextPage = batchConnection.pageInfo.hasNextPage;
          }
        } 

        if(isForward) nonaEdges = [...nonaEdges, ...batchEdges.slice(0, (requiredItems - nonaEdges.length)) ];
        else          nonaEdges = [...batchEdges.slice(-(requiredItems - nonaEdges.length)), ...nonaEdges ];
      }

      /**
       *    1.4 Check number of fetched items:
       *        1.4.1  If: fetched items are less than the requested number of items in 1.2 and there are more items:
       *               1.4.1.1 Adjust pagination to get the next batch of items.
       *               1.4.1.2 @continue with next iteration.
       *        1.4.2  Else: fetched items are equal to the requested number of items in 1.2 or there are no more items: 
       *               1.4.2.1 Return Connection with edges and pageInfo properly configured.  
       *               1.4.2.2 @done
       * 
       */
      let thereAreMoreItems = isForward ? batchConnection.pageInfo.hasNextPage : batchConnection.pageInfo.hasPreviousPage;

      if(nonaEdges.length < requiredItems && thereAreMoreItems) {
        //adjust pagination for next batch associated ids
        batchPagination.after = isForward ? batchConnection.pageInfo.endCursor : null;
        batchPagination.before = !isForward ? batchConnection.pageInfo.startCursor : null;
        batchPagination.includeCursor = false;
        batchVariables = {pagination: batchPagination};

        //continue with next iteration...
      } else {
        
        //adjust pagination info (end)
        if(nonaEdges.length > 0) {
          if(isForward) {
            nonaPageInfo.endCursor = nonaEdges[nonaEdges.length - 1].cursor;
            nonaPageInfo.hasNextPage = batchConnection.pageInfo.hasNextPage || thereAreMoreNonaItems;
          } else {
            nonaPageInfo.startCursor = nonaEdges[0].cursor;
            nonaPageInfo.hasPreviousPage = batchConnection.pageInfo.hasPreviousPage || thereAreMoreNonaItems;
          }
        }

        //delete innerConnecton and cursor
        for(let i=0; i<nonaEdges.length; i++) {
          delete nonaEdges[i].node["<%- sortedAssociations[i].peerAssociationNameLc _%>Connection"];
          delete nonaEdges[i].cursor;
        }

        //set final connection
        let connection = {pageInfo: nonaPageInfo, edges: nonaEdges};
        //ok
        return {value: connection, message: 'ok', graphqlErrors: (graphqlErrors.length>0) ? graphqlErrors : undefined};
      }
    }//end: while()

    /////////////////////////////
    /**
     * Alternative algorithm.
     */

    // //checks
    // if(!variables&&!variables.pagination&&typeof variables.pagination !== 'object' ) throw new Error("internal_error: pagination object expected");
    // if(!variables.pagination.first&&!variables.pagination.last ) throw new Error("internal_error: pagination first or last positive argument expected");

    // /**
    //  * Alternative Algorithm: fetch not associated items excluding associated ones in batches.
    //  * 
    //  * Recursive fetch of not associated items algorithm (cursor-based-pagination):
    //  *  1 Until @requiredItems are fetched, do:
    //  *    1.1 Get @batchSize associated ids.
    //  *    1.2 Get @requiredItems ( equal to @first or @last ) minus lenght.of( @notAssociatedItems already fetched) items, 
    //  *        with a search filter excluding the set of associated ids fetched at 1.1 and not exceeding the last (or first) 
    //  *        associated id in this set.
    //  *    1.3 Join fetched items in 1.2 with previous ones if any: in @notAssociatedItemsEdges array.
    //  *    1.4 Check number of items fetched:
    //  *        1.4.1  If: fetched items are less than the requested number of items in 1.2 and there are more items:
    //  *               1.4.1.1 Adjust pagination to get the next batch of associated ids and next not-associated items page.
    //  *               1.4.1.2 @continue with next iteration.
    //  *        1.4.2  Else: fetched items are equal to the requested number of items in 1.2 or there are no more items:
    //  *               1.4.2.1 Return Connection with edges and pageInfo properly configured. 
    //  *               1.4.2.2 @done
    //  */

    // //set direction
    // let isForward = variables.pagination.first ? true : false;
    // //set required number of items
    // let requiredItems = isForward ? variables.pagination.first : variables.pagination.last;

    // //initialize pagination for batch associated ids
    // let batchPagination = {...variables.pagination, first: isForward ? batchSize : null, last: !isForward ? batchSize : null, includeCursor: false};
    // let batchVariables = {pagination: batchPagination};
    // let batchSearch = getSearchArgument('<%- sortedAssociations[i].targetModelLc _%>', searchText, ops);
    // let batchQuery = '';

    // //initialize pagination for non-associated items
    // let nonaPagination = {...variables.pagination};
    // let nonaVariables = {pagination: nonaPagination};
    // let nonaPageInfo = {startCursor: null, endCursor: null, hasPreviousPage: false, hasNextPage: false};
    // let nonaEdges = [];
    // let nonaQuery = '';

    // //general search ands filters
    // let sands = getSearchArgument('<%- sortedAssociations[i].targetModelLc _%>', searchText, ops, 'ands');

    // /**
    //  * Recursive fetch of not associated items algorithm (cursor-based-pagination):
    //  *  1 Until @requiredItems are fetched, do:
    //  * 
    //  */
    // let iteration = 0;
    // let nonaSands = '';
    // while(nonaEdges.length < requiredItems) {
    //   //init with general search ands filters
    //   nonaSands = sands;

    //   /**
    //    * 1.1 Get @batchSize associated ids.
    //    * 
    //    */
    //   if(batchSearch) {
    //     batchQuery =
    //       `query readOne<%- nameCp _%>($pagination: paginationCursorInput) {
    //         readOne<%- nameCp _%>(<%- internalId _%>: "${itemId}") {
    //           <%- sortedAssociations[i].relationNameLc _%>Connection( ${batchSearch}, pagination: $pagination ) {
    //             pageInfo {startCursor endCursor hasPreviousPage hasNextPage}
    //             edges {node {<%- sortedAssociations[i].internalId _%>}}
    //         }}}`;
    //   } else {
    //     batchQuery =
    //       `query readOne<%- nameCp _%>($pagination: paginationCursorInput) {
    //         readOne<%- nameCp _%>(<%- internalId _%>: "${itemId}") {
    //           <%- sortedAssociations[i].relationNameLc _%>Connection( pagination: $pagination ) {
    //             pageInfo {startCursor endCursor hasPreviousPage hasNextPage}
    //             edges {node {<%- sortedAssociations[i].internalId _%>}}
    //         }}}`;
    //   }

    //   /**
    //    * Debug
    //    */
    //   console.log("getNotAssociated<%- sortedAssociations[i].relationNameCp %>.batchQuery: gql:\n", batchQuery);
    //   console.log("getNotAssociated<%- sortedAssociations[i].relationNameCp %>.batchVariables: gql:\n", batchVariables);
      
    //   let batchConnection = null;
    //   let response = await requestGraphql({ url, query:batchQuery, variables:batchVariables });
    //   //check
    //   let check = checkResponse(response, graphqlErrors, "readOne<%- nameCp _%>");
    //   if(check === 'ok') {
    //     if( response.data.data["readOne<%- nameCp _%>"] ) {
    //       //check type
    //       if(typeof response.data.data["readOne<%- nameCp _%>"] !== 'object'
    //       || response.data.data["readOne<%- nameCp _%>"]["<%- sortedAssociations[i].relationNameLc _%>Connection"] === null
    //       || typeof response.data.data["readOne<%- nameCp _%>"]["<%- sortedAssociations[i].relationNameLc _%>Connection"] !== 'object'
    //       || !Array.isArray(response.data.data["readOne<%- nameCp _%>"]["<%- sortedAssociations[i].relationNameLc _%>Connection"].edges)
    //       || typeof response.data.data["readOne<%- nameCp _%>"]["<%- sortedAssociations[i].relationNameLc _%>Connection"].pageInfo !== 'object' 
    //       || response.data.data["readOne<%- nameCp _%>"]["<%- sortedAssociations[i].relationNameLc _%>Connection"].pageInfo === null)
    //       return {data: response.data.data, value: null, message: 'bad_type', graphqlErrors: (graphqlErrors.length>0) ? graphqlErrors : undefined};

    //       //get value
    //       batchConnection = response.data.data["readOne<%- nameCp _%>"]["<%- sortedAssociations[i].relationNameLc _%>Connection"];

    //     } else return {data: response.data.data, value: null, message: 'bad_format', graphqlErrors: (graphqlErrors.length>0) ? graphqlErrors : undefined};
    //   } else return {data: response.data.data, value: null, message: check, graphqlErrors: (graphqlErrors.length>0) ? graphqlErrors : undefined};
      
    //   //get ids to exclude
    //   let idsToExclude = batchConnection.edges.map(o => o.node.<%- sortedAssociations[i].internalId _%>);

    //   /**
    //    * Debug
    //    */
    //   console.log("@@-- iteration: ", iteration);
    //   console.log("@@-- requiredItems: ", requiredItems);
    //   console.log("@@-- batchConnection: ", batchConnection);
    //   console.log("@@-- idsToExclude: ", idsToExclude);

    //   /**
    //    * 1.2 Get @requiredItems ( equal to @first or @last ) minus lenght.of( @notAssociatedItems already fetched) items, 
    //    *      with a search filter excluding the set of associated ids fetched at 1.1 and not exceeding the last (or first) 
    //    *      associated id in this set.
    //    */
    //   //case: there are associated items to exclude...
    //   if(idsToExclude.length > 0) {
    //     //add exclusions
    //     let nonaOps = {
    //       exclude: [{
    //         type: '<%- sortedAssociations[i].internalIdType _%>',
    //         values: {"<%- sortedAssociations[i].internalId _%>": idsToExclude}
    //       }]
    //     };
        
    //     //get search ands filters
    //     let nonaSearchAnds = getSearchArgument('<%- sortedAssociations[i].targetModelLc _%>', searchText, nonaOps, 'ands');
    //     //add exclusion filters to general search ands
    //     nonaSands += nonaSearchAnds;

    //     if(isForward) {
    //       //case: there are more associated ids...
    //       if(batchConnection.pageInfo.hasNextPage) {
    //         /**
    //          * Debug
    //          */
    //         console.log("@@-- forward: limit next result to:  idsToExclude[last]: ", idsToExclude[idsToExclude.length-1]);

    //         //make filter to limit results to before the last associated id.
    //         let f1 = `{field: <%- sortedAssociations[i].internalId _%>, valueType: <%- sortedAssociations[i].internalIdType _%>, value: "${idsToExclude[idsToExclude.length-1]}", operator: lt}`;
    //         let nf = `{operator: or, search: [ ${f1} ]}`;

    //         //add new filter to general search ands
    //         nonaSands += nf;
    //       }
    //     } else { //isBackward
    //       //case: there are more associated ids...
    //       if(batchConnection.pageInfo.hasPreviousPage) {
    //         /**
    //          * Debug
    //          */
    //         console.log("@@-- backward: limit next result to:  idsToExclude[first]: ", idsToExclude[0]);
          
    //         //make filter to limit results to after the first associated id.
    //         let f1 = `{field: <%- sortedAssociations[i].internalId _%>, valueType: <%- sortedAssociations[i].internalIdType _%>, value: "${idsToExclude[0]}", operator: gt}`;
    //         let nf = `{operator: or, search: [ ${f1} ]}`;

    //         //add new filter to general search ands
    //         nonaSands += nf;
    //       }
    //     }
    //   } 

    //   if(nonaSands !== '') {
    //     //make search
    //     let nonaSearch = `search: {operator:and, search: [ ${nonaSands} ]}`;
    //     nonaQuery =
    //       `query <%- sortedAssociations[i].targetModelPlLc _%>Connection($pagination: paginationCursorInput) {
    //           <%- sortedAssociations[i].targetModelPlLc _%>Connection( ${nonaSearch}, pagination: $pagination ) {
    //             pageInfo {startCursor endCursor hasPreviousPage hasNextPage}
    //             edges {node {${qattributes}}}
    //         }}`;
    //   } else {
    //     nonaQuery =
    //       `query <%- sortedAssociations[i].targetModelPlLc _%>Connection($pagination: paginationCursorInput) {
    //         <%- sortedAssociations[i].targetModelPlLc _%>Connection( pagination: $pagination ) {
    //           pageInfo {startCursor endCursor hasPreviousPage hasNextPage}
    //           edges {node {${qattributes}}}
    //       }}`;
    //   }

    //   /**
    //    * Debug
    //    */
    //   console.log("getNotAssociated<%- sortedAssociations[i].relationNameCp %>.nonaQuery: gql:\n", nonaQuery);
    //   console.log("getNotAssociated<%- sortedAssociations[i].relationNameCp %>.nonaVariables: gql:\n", nonaVariables);
      
    //   /**
    //    * Request
    //    */
    //   let nonaConnection = null;
    //   response = await requestGraphql({ url, query:nonaQuery, variables:nonaVariables });
    //   //check
    //   check = checkResponse(response, graphqlErrors, "<%- sortedAssociations[i].targetModelPlLc _%>Connection");
    //   if(check === 'ok') {
    //     if( response.data.data["<%- sortedAssociations[i].targetModelPlLc _%>Connection"] ) {
    //       //check type
    //       if(typeof response.data.data["<%- sortedAssociations[i].targetModelPlLc _%>Connection"] !== 'object'
    //       || !Array.isArray(response.data.data["<%- sortedAssociations[i].targetModelPlLc _%>Connection"].edges)
    //       || typeof response.data.data["<%- sortedAssociations[i].targetModelPlLc _%>Connection"].pageInfo !== 'object' 
    //       || response.data.data["<%- sortedAssociations[i].targetModelPlLc _%>Connection"].pageInfo === null)
    //       return {data: response.data.data, value: null, message: 'bad_type', graphqlErrors: (graphqlErrors.length>0) ? graphqlErrors : undefined};

    //       //get value
    //       nonaConnection = response.data.data["<%- sortedAssociations[i].targetModelPlLc _%>Connection"];

    //     } else return {data: response.data.data, value: null, message: 'bad_format', graphqlErrors: (graphqlErrors.length>0) ? graphqlErrors : undefined};
    //   } else return {data: response.data.data, value: null, message: check, graphqlErrors: (graphqlErrors.length>0) ? graphqlErrors : undefined};

    //   /**
    //    * Debug
    //    */
    //   console.log("@@-- nonaConnection: ", nonaConnection);

    //   /**
    //    * 1.3 Join fetched items in 1.2 with previous ones if any: in @notAssociatedItemsEdges array.
    //    */
    //   if(nonaConnection.edges.length > 0) { //if there are new items...
    //     //adjust pageInfo for the first non associated items
    //     if(nonaEdges.length === 0) {
    //       nonaPageInfo = { ...nonaConnection.pageInfo};
    //     } else {  //adjust pageInfo for the last non associated items
    //       if(isForward) {
    //         nonaPageInfo.endCursor = nonaConnection.pageInfo.endCursor;
    //         nonaPageInfo.hasNextPage = nonaConnection.pageInfo.hasNextPage;
    //       } else {
    //         nonaPageInfo.startCursor = nonaConnection.pageInfo.startCursor;
    //         nonaPageInfo.hasPreviousPage = nonaConnection.pageInfo.hasPreviousPage;
    //       }
    //     } 
    //     //join new items      
    //     if(isForward) nonaEdges = [...nonaEdges, ...nonaConnection.edges ];
    //     else          nonaEdges = [...nonaConnection.edges, ...nonaEdges ];
    //   }

    //   /**
    //    * Debug
    //    */
    //   console.log("@@-- nonaEdges: ", nonaEdges);

    //   /**
    //    * 1.4 Check number of items fetched:
    //    *    1.4.1  If: fetched items are less than the requested number of items in 1.2 and there are more items:
    //    *           1.4.1.1 Adjust pagination to get the next batch of associated ids and next not-associated items page.
    //    *           1.4.1.2 @continue with next iteration.
    //    *    1.4.2  If: fetched items are equal to the requested number of items in 1.2 or there are no more items:
    //    *           1.4.2.1 Return Connection with edges and pageInfo properly configured. 
    //    *           1.4.2.2 @done
    //    */
    //   let thereAreMoreItems = isForward ? batchConnection.pageInfo.hasNextPage : batchConnection.pageInfo.hasPreviousPage;

    //   /**
    //    * Debug
    //    */
    //   console.log("@@-- thereAreMoreItems: ", thereAreMoreItems);
    //   console.log("@@-- nonaEdges.length : ", nonaEdges.length);

    //   if(nonaEdges.length < requiredItems && thereAreMoreItems) {
    //     //adjust pagination for next batch associated ids
    //     batchPagination.after = isForward ? batchConnection.pageInfo.endCursor : null;
    //     batchPagination.before = !isForward ? batchConnection.pageInfo.startCursor : null;
    //     batchVariables = {pagination: batchPagination};
        
    //     //adjust pagination for the next non-associated items
    //     nonaPagination.first = isForward ? (requiredItems - nonaEdges.length) : null;
    //     nonaPagination.last = !isForward ? (requiredItems - nonaEdges.length) : null;
    //     nonaPagination.after = isForward ? batchConnection.pageInfo.endCursor : null;
    //     nonaPagination.before = !isForward ? batchConnection.pageInfo.startCursor : null;
    //     nonaPagination.includeCursor = false;
    //     nonaVariables = {pagination: nonaPagination};

    //     //continue with next iteration...
    //   } else {        
    //     let connection = {pageInfo: nonaPageInfo, edges: nonaEdges};
    //     //ok
    //     return {value: connection, message: 'ok', graphqlErrors: (graphqlErrors.length>0) ? graphqlErrors : undefined};
    //   }
    // }//end: while()
<%}-%>
<%}-%> 
  },
<%}-%>  
  
/**
   * getItemsAttribute
   *
   * Get all items from GraphQL Server using a cursor-based-connection. Get only the indicated
   * attribute. No search, order or pagination are specified in this function, so
   * all items will be retrieved without a particular order or search filter.
   *
   * @param {String} url GraphQL Server url
   * @param {String} attribute Name of the attribute to be retrieved.
   */
  getItemsAttribute(url, attribute) {
    let query =
      `query
          { <%- namePlLc _%>Connection {
            edges {
              node {
                ${attribute}
              }
            }
          }}`;
    /**
     * Debug
     */
    console.log("getItemsAttribute.query: gql:\n", query);

    return requestGraphql({ url, query });

  },
}//end: export default

/**
 * Utils
 */
function getSearchArgument(filterName, searchText, ops, justAnds) {

  var filterAttributes = getAttributes(filterName);
  var modelAttributes = Object.keys(filterAttributes);
  var ors = '';
  var orSearch = null;
  var ands = '';
  var andSearch = null;

  if(searchText !== null && searchText !== '' && modelAttributes.length > 0) {
    /*
      Make AND fields
    */
    var words = searchText.split(' ');

    //for each word
    for(let w = 0; w < words.length; w++) {
      /*
        Make OR fields
      */

      //for each attribute
      for(let i = 0; i < modelAttributes.length; i++) {
        let num = 0;
        let d = '';
        let t = '';
        let dt = '';

        switch (filterAttributes[modelAttributes[i]]) {
          case 'String':
            //add
            ors += `{field:${modelAttributes[i]}, value:"%${words[w]}%", operator:like},`
            break;

          case 'Int':
            num = parseInt(words[w]);
            //add if: word is an integer number
            if (!isNaN(num)) {
              ors += `{field:${modelAttributes[i]}, value:"${num}", operator:eq},`
            }
            break;

          case 'Float':
            num = parseFloat(words[w]);
            //add if: word is a float number
            if (!isNaN(num)) {
              ors += `{field:${modelAttributes[i]}, value:"${num}", operator:eq},`
            }
            break;

          case 'Boolean':
            //add if: word is 'true' or 'false'
            if (words[w] === 'true' || words[w] === 'false') {
              ors += `{field:${modelAttributes[i]}, value:"${words[w]}", operator:eq},`
            }
            break;

          case 'Date':
            d = getIsoDate(words[w]);
            //add if: word is an ISO date
            if (d !== '') {
              ors += `{field:${modelAttributes[i]}, value:"${d}", operator:eq},`
            }
            break;

          case 'Time':
            t = getIsoTime(words[w]);
            //add if: word is an ISO time
            if (t !== '') {
              ors += `{field:${modelAttributes[i]}, value:"${t}", operator:eq},`
            }
            break;

          case 'DateTime':
            dt = getIsoDateTime(words[w]);
            //add if: word is an ISO datetime
            if (dt !== '') {
              ors += `{field:${modelAttributes[i]}, value:"${dt}", operator:eq},`
            }
            break;

          default:
            break;
        }

        //make OR search argument
        orSearch = `{operator:or, search: [ ${ors} ]},`

      }//end: for each attribute (ORs)

      //add to ANDs
      ands += orSearch;

    }//end: for each word (ANDs)

    /*
      Options
    */
    if (ops !== undefined && ops !== null && typeof ops === 'object') {

      /*
        -- 'only' option --
        For each field name in only array, an AND search argument will be added to search string.

        Format:
          {
            only: [
              {
                values: {
                  'fieldName1': ['value1', 'value2', ..., 'valueN'],
                  ...
                  'fieldNameM': ['value1', 'value2', ..., 'valueN'],
                }
                type: 'type'
              },
              ...
              {
                values: {
                  'fieldName1': ['value1', 'value2', ..., 'valueN'],
                  ...
                  'fieldNameN': ['value1', 'value2', ..., 'valueN'],
                }
                type: 'type'
              }
            ]
          }
      */
      if (ops.hasOwnProperty('only') && Array.isArray(ops.only)) {
        let onlyOrs = '';
        let onlySearch = '';

        //for each only object
        for(let i = 0; i < ops.only.length; i++) {
          let o = ops.only[i];
          /*
            Switch type
            At the momment, this only works for [InternalId] fields.
            An internalID can be of types: Int, Float or String.
          */
          if (o.type === 'Int' || o.type === 'Float' || o.type === 'String') {
            let v = o.values;
            let vkeys = Object.keys(v);

            //for each key
            for(let k = 0; k < vkeys.length; k++) {
              let va = v[vkeys[k]]; //values array

              //in
              onlyOrs += `{field:${vkeys[k]}, valueType: Array, value:"${va.join()}", operator:in},`

            }//end: for earch key
          }//end: if type 'Int
        }//end: for earch only object

        onlySearch = `{operator:or, search: [ ${onlyOrs} ]},`;
        ands += onlySearch;

      }//end: if has 'only'

      /*
        -- 'exclude' option --
        For each field name in exclude array, an AND search argument will be added to search string.

        Format:
          {
            exclude: [
              {
                values: {
                  'fieldName1': ['value1', 'value2', ..., 'valueN'],
                  ...
                  'fieldNameM': ['value1', 'value2', ..., 'valueN'],
                }
                type: 'type'
              },
              ...
              {
                values: {
                  'fieldName1': ['value1', 'value2', ..., 'valueN'],
                  ...
                  'fieldNameN': ['value1', 'value2', ..., 'valueN'],
                }
                type: 'type'
              }
            ]
          }
      */
      if (ops.hasOwnProperty('exclude') && Array.isArray(ops.exclude)) {
        //for each exclude object
        for(let i = 0; i < ops.exclude.length; i++) {
          let o = ops.exclude[i];

          /*
            Switch type
            At the momment, this only works for [InternalId] fields.
            An internalID can be of types: Int, Float or String.
          */
          if (o.type === 'Int' || o.type === 'Float' || o.type === 'String') {
            let v = o.values;
            let vkeys = Object.keys(v);

            //for each key
            for(let k = 0; k < vkeys.length; k++) {
              let va = v[vkeys[k]]; //values array

              //notIn
              ands += `{field:${vkeys[k]}, valueType: Array, value:"${va.join()}", operator:notIn},`

            }//end: for earch key
          }//end: if type 'Int
        }//end: for earch exclude object
      }//end: if has 'exclude'
    }//end: if has 'ops'

    //make search argument
    andSearch = `search: {operator:and, search: [ ${ands} ]}`
  }//end: if searchText
  else {
    /*
      Check: ops
    */
    /*
      Options
    */
    if (ops !== undefined && ops !== null && typeof ops === 'object') {
      /*
        -- 'only' option --
        For each field name in only array, an AND search argument will be added to search string.

        Format:
          {
            only: [
              {
                values: {
                  'fieldName1': ['value1', 'value2', ..., 'valueN'],
                  ...
                  'fieldNameM': ['value1', 'value2', ..., 'valueN'],
                }
                type: 'type'
              },
              ...
              {
                values: {
                  'fieldName1': ['value1', 'value2', ..., 'valueN'],
                  ...
                  'fieldNameN': ['value1', 'value2', ..., 'valueN'],
                }
                type: 'type'
              }
            ]
          }
      */
      if (ops.hasOwnProperty('only') && Array.isArray(ops.only)) {
        let onlyOrs = '';
        let onlySearch = '';

        //for each only object
        for(let i = 0; i < ops.only.length; i++) {
          let o = ops.only[i];
          /*
            Switch type
            At the momment, this only works for [InternalId] fields.
            An internalID can be of types: Int, Float or String.
          */
          if (o.type === 'Int' || o.type === 'Float' || o.type === 'String') {
            let v = o.values;
            let vkeys = Object.keys(v);

            //for each key
            for(let k = 0; k < vkeys.length; k++) {
              let va = v[vkeys[k]]; //values array

              //in
              onlyOrs += `{field:${vkeys[k]}, valueType: Array, value:"${va.join()}", operator:in},`

            }//end: for earch key
          }//end: if type 'Int
        }//end: for earch only object

        onlySearch = `{operator:or, search: [ ${onlyOrs} ]},`;
        ands += onlySearch;

      }//end: if has 'only'

      /*
        -- 'exclude' option --
        For each field name in exclude array, an AND search argument will be added to search string.

        Format:
          {
            exclude: [
              {
                values: {
                  'fieldName1': ['value1', 'value2', ..., 'valueN'],
                  ...
                  'fieldNameM': ['value1', 'value2', ..., 'valueN'],
                }
                type: 'type'
              },
              ...
              {
                values: {
                  'fieldName1': ['value1', 'value2', ..., 'valueN'],
                  ...
                  'fieldNameN': ['value1', 'value2', ..., 'valueN'],
                }
                type: 'type'
              }
            ]
          }
      */
      if (ops.hasOwnProperty('exclude') && Array.isArray(ops.exclude)) {

        //for each exclude object
        for(let i = 0; i < ops.exclude.length; i++) {
          let o = ops.exclude[i];
          /*
            Switch type
            At the momment, this only works for [InternalId] fields.
            An internalID can be of types: Int, Float or String.
          */
          if (o.type === 'Int' || o.type === 'Float' || o.type === 'String') {
            let v = o.values;
            let vkeys = Object.keys(v);

            //for each key
            for(let k = 0; k < vkeys.length; k++) {
              let va = v[vkeys[k]]; //values array

              //notIn
              ands += `{field:${vkeys[k]}, valueType: Array, value:"${va.join()}", operator:notIn},`

            }//end: for earch key
          }//end: if type 'Int
        }//end: for earch exclude object
      }//end: if has 'exclude'

      //make search argument
      andSearch = `search: {operator:and, search: [ ${ands} ]}`
    }//end: if has 'ops'
  }//end: if !searchText

  return justAnds ? ands : andSearch;
}

function getIsoDate(text) {
  //if has the form: aaaa[-/]mm[-/]dd
  if (/^\d{4}[-/][01]\d[-/][0-3]\d/.test(text)) {

    let m = text.slice(5, 7);
    let d = text.slice(8, 10);

    let numM = parseInt(m);
    let numD = parseInt(d);

    //if has the correct content
    if ((numM >= 1 && numM <= 12) && (numD >= 1 && numD <= 31)) {
      return text;
    }
  }
  return '';
}

function getIsoTime(text) {

  /**
   * Case: complete precision: hh:mm:ss.d+
   */
  if (/^[0-2]\d:[0-5]\d:[0-5]\d\.\d+/.test(text)) {

    let h = text.slice(0, 2);
    let numH = parseInt(h);

    if (numH >= 0 && numH <= 23) {
      return text;
    }

    return '';
  } else {
    /**
     * Case: no milliseconds: hh:mm:ss
     */
    if (/^[0-2]\d:[0-5]\d:[0-5]\d/.test(text)) {

      let h = text.slice(0, 2);
      let numH = parseInt(h);

      if (numH >= 0 && numH <= 23) {
        return text;
      }

      return '';
    } else {
      /**
       * Case: no seconds: hh:mm
       */
      if (/^[0-2]\d:[0-5]\d/.test(text)) {

        let h = text.slice(0, 2);
        let numH = parseInt(h);

        if (numH >= 0 && numH <= 23) {
          return text;
        }

        return '';
      }
    }
  }

  return '';
}

function getIsoDateTime(text) {

  /**
   * Case: complete precision: YYYY[-/]MM[-/]DD[ T]hh:mm:ss.d+
   */
  if (/^\d{4}[/-][01]\d[/-][0-3]\d[T ][0-2]\d:[0-5]\d:[0-5]\d\.\d+/.test(text)) {

    let M = text.slice(5, 7);
    let D = text.slice(8, 10);
    let h = text.slice(11, 13);

    let numM = parseInt(M);
    let numD = parseInt(D);
    let numH = parseInt(h);

    //if content ok
    if ((numM >= 1 && numM <= 12) && (numD >= 1 && numD <= 31) && (numH >= 0 && numH <= 23)) {
      return text;
    }

    return '';
  } else {
    /**
     * Case: no milliseconds: YYYY[-/]MM[-/]DD[ T]hh:mm:ss
     */
    if (/^\d{4}[/-][01]\d[/-][0-3]\d[T ][0-2]\d:[0-5]\d:[0-5]\d/.test(text)) {

      let M = text.slice(5, 7);
      let D = text.slice(8, 10);
      let h = text.slice(11, 13);

      let numM = parseInt(M);
      let numD = parseInt(D);
      let numH = parseInt(h);

      //if content ok
      if ((numM >= 1 && numM <= 12) && (numD >= 1 && numD <= 31) && (numH >= 0 && numH <= 23)) {
        return text;
      }

      return '';
    } else {
      /**
       * Case: no seconds: YYYY[-/]MM[-/]DD[ T]hh:mm
       */
      if (/^\d{4}[/-][01]\d[/-][0-3]\d[T ][0-2]\d:[0-5]\d/.test(text)) {

        let M = text.slice(5, 7);
        let D = text.slice(8, 10);
        let h = text.slice(11, 13);

        let numM = parseInt(M);
        let numD = parseInt(D);
        let numH = parseInt(h);

        //if content ok
        if ((numM >= 1 && numM <= 12) && (numD >= 1 && numD <= 31) && (numH >= 0 && numH <= 23)) {
          return text;
        }

        return '';
      } else {
        /**
         * Case: no time: YYYY[-/]MM[-/]DD
         */
        if (/^\d{4}[/-][01]\d[/-][0-3]\d/.test(text)) {

          let M = text.slice(5, 7);
          let D = text.slice(8, 10);

          let numM = parseInt(M);
          let numD = parseInt(D);

          //if content ok
          if ((numM >= 1 && numM <= 12) && (numD >= 1 && numD <= 31)) {
            return text;
          }

          return '';
        }
      }
    }
  }

  return '';
}

<%_if( sortedAssociations.length > 0 ){-%>
function checkResponse(response, graphqlErrors, queryName) {
  //check: internal errors
  if(!Array.isArray(graphqlErrors)) throw new Error("internal_error: array expected");
  if(typeof queryName !== 'string') throw new Error("internal_error: string expected");
  
  //check: server error
  if(!response||!response.data) throw new Error("bad_server_response");
  //check: graphql errors
  if(response.data.errors) graphqlErrors.push({query: queryName, errors: response.data.errors});
  //check: data errors
  if(response.data.data === undefined) return "no_data"; 
  if(response.data.data === null) return "null_data";
  if(response.data.errors) return "with_errors";

  return "ok";
}
<%}-%>