import { 
  requestGraphql, checkResponse, getSearchArgument, logRequest } from '../utils'
import getAttributes from './requests.attributes'
import globals from '../config/globals';

export default {

<%#
/**
 * Request:
 *  Get model table template (root query).
 * 
 * Methods:
 *   - tableTemplate
 * 
 */
-%>
  /**
   * tableTemplate
   *
   * Get <%- nameLc _%> table template from GraphQL Server.
   * (root query)
   *
   * @param {String} url GraphQL Server url
   */
  tableTemplate(url) {
    let query = `query {csvTableTemplate<%- nameCp _%>}`

    /**
     * Debug
     */
    if(globals.REQUEST_LOGGER) logRequest('tableTemplate', query );
    return requestGraphql({ url, query });
  },

<%#
/**
 * Request:
 *  Get items count (root query).
 * 
 * Methods:
 *   - getCountItems
 * 
 */
-%>
  /**
   * getCountItems
   *
   * Get <%- namePlLc _%> items count from GraphQL Server.
   * (root query)
   *
   * @param {String} url GraphQL Server url
   * @param {String} searchText Text string currently on search bar.
   * @param {String} ops Object with adittional query options.
   */
  getCountItems(url, searchText, ops) {
    let variables = {};
    //search
    let s = getSearchArgument('<%- nameLc _%>', searchText, ops, 'object');
    if(s) variables.search = s.search;

    //query
    let attributes = getAttributes('<%- nameLc _%>');
    let qattributes = Object.keys(attributes).join();
    let query =
      `query count<%- namePlCp _%>($search: search<%- nameCp _%>Input) { 
             count<%- namePlCp _%>( search: $search ) }`
    /**
     * Debug
     */
    if(globals.REQUEST_LOGGER) logRequest('getCountItems', query, variables);

    return requestGraphql({ url, query });
  },

<%#
/**
 * Request:
 *  Get items (root query).
 * 
 * Methods:
 *   - limitOffset: getItems
 *   - cursorBased: getItemsConnection
 * 
 */
-%>
<%if(paginationType === 'limitOffset') {-%>
  /**
   * getItems
   *
   * Get <%- namePlLc _%> items from GraphQL Server.
   * (root query)
   *
   * @param {String} url GraphQL Server url
   * @param {String} searchText Text string currently on search bar.
   * @param {String} orderBy Order field string.
   * @param {String} orderDirection Text string: asc | desc.
   * @param {Number} paginationOffset Offset.
   * @param {Number} paginationLimit Max number of items to retreive.
   * @param {String} ops Object with adittional query options.
   */
  getItems(url, searchText, orderBy, orderDirection, paginationOffset, paginationLimit, ops) {
    let variables = {};
    //pagination
    variables.pagination = {offset: paginationOffset, limit: paginationLimit};
    //search
    let s = getSearchArgument('<%- nameLc _%>', searchText, ops, 'object');
    if(s) variables.search = s.search;
    //order
    if(orderBy && orderDirection) {
      let upOrderDirection = String(orderDirection).toUpperCase();
      variables.order = [ {field: orderBy, order: upOrderDirection} ]
    }
    //query
    let attributes = getAttributes('<%- nameLc _%>');
    let qattributes = Object.keys(attributes).join();
    let query =
      `query <%- namePlLc _%>($order: [order<%- nameCp _%>Input], $search: search<%- nameCp _%>Input, $pagination: paginationInput) { 
             <%- namePlLc _%>( order: $order, search: $search, pagination: $pagination ) {
                ${qattributes} }
       }`
    /**
     * Debug
     */
    if(globals.REQUEST_LOGGER) logRequest('getItems', query, variables);
    return requestGraphql({ url, query });
  },
<%} else if(paginationType === 'cursorBased') {-%>
  /**
   * getItemsConnection
   *
   * Get items from GraphQL Server using a cursor-based-connection.
   *
   * @param {String} url GraphQL Server url
   * @param {String} searchText Text string currently on search bar.
   * @param {String} orderBy Order field string.
   * @param {String} orderDirection Text string: asc | desc.
   * @param {Object} variables Object with cursor-based-pagination variables.
   * @param {String} ops Object with additional query options.
   */
  getItemsConnection(url, searchText, orderBy, orderDirection, variables, ops) {
    //search
    let s = getSearchArgument('<%- nameLc _%>', searchText, ops, 'object');
    if(s) variables.search = s.search;
    //order
    if(orderBy && orderDirection) {
      let upOrderDirection = String(orderDirection).toUpperCase();
      variables.order = [ {field: orderBy, order: upOrderDirection} ]
    }
    //query
    let attributes = getAttributes('<%- nameLc _%>');
    let qattributes = Object.keys(attributes).join();
    let query =
      `query <%- namePlLc _%>Connection($order: [order<%- nameCp _%>Input], $search: search<%- nameCp _%>Input, $pagination: paginationCursorInput) { 
             <%- namePlLc _%>Connection( order: $order, search: $search, pagination: $pagination ) {
                pageInfo { startCursor, endCursor, hasPreviousPage, hasNextPage }
                edges { node { ${qattributes} }}
       }}`
    /**
     * Debug
     */
    if(globals.REQUEST_LOGGER) logRequest('getItemsConnection', query, variables);
    return requestGraphql({ url, query, variables });
  },
<%}-%>

<%#
/**
 * Request:
 *  Create new item (root mutation).
 * 
 * Methods:
 *   - createItem
 * 
 */
-%>
  /**
   * createItem
   *
   * Add new <%- nameCp %> item on GraphQL Server.
   * (root mutation)
   *
   * @param {String} url GraphQL Server url.
   * @param {Object} variables Object with values to create new <%- nameCp %> item.
   */
  createItem(url, variables) {
    //query
    let query =
      `mutation add<%- nameCp %>(
<%if(!isDefaultId){-%>
          $<%- internalId _%>:ID!,
<%}-%>
<%_for( let i=0; i<attributesArr.length; i++ ){
  /*
   * Render each attribute, except FK attributes and internalId.
   */

  let a = attributesArr[i][0];
  let isForeignKey = (hasOwnForeingKeys&&ownForeignKeysArr.includes(a));
  if(!isForeignKey && (attributesArr[i][0] !== internalId)) {
-%>
          $<%- attributesArr[i][0] _%>:<%- attributesArr[i][1] _%>,
<%}}-%>
<%for( let i=0; i<sortedAssociations.length; i++ ){
  /*
   * Render each toAdd attributes for to_one associations.
   */

  if(sortedAssociations[i].type === 'to_one' || sortedAssociations[i].type === 'generic_to_one') {
-%>
          $add<%- sortedAssociations[i].relationNameCp _%>: ID,
<%}}-%>
<%_for( let i=0; i<sortedAssociations.length; i++ ){
  /*
   * Render each toAdd attributes for to_many associations.
   */

  if(sortedAssociations[i].type === 'to_many' || sortedAssociations[i].type === 'to_many_through_sql_cross_table' || sortedAssociations[i].type === 'generic_to_many') {
-%>
          $add<%- sortedAssociations[i].relationNameCp _%>: [ID],
<%}}-%>
          ) { add<%- nameCp %>(
<%if(!isDefaultId){-%>
            <%- internalId _%>:$<%- internalId _%>,
<%}-%>
<%_for( let i=0; i<attributesArr.length; i++ ){
  /*
   * Render each attribute, except FK attributes and internalId.
   */

  let a = attributesArr[i][0];
  let isForeignKey = (hasOwnForeingKeys&&ownForeignKeysArr.includes(a));
  if(!isForeignKey && (attributesArr[i][0] !== internalId)) {
-%>
            <%- attributesArr[i][0] _%>:$<%- attributesArr[i][0] _%>,
<%}}-%>
<%for( let i=0; i<sortedAssociations.length; i++ ){
  /*
   * Render each toAdd attributes for to_one associations.
   */

  if(sortedAssociations[i].type === 'to_one' || sortedAssociations[i].type === 'generic_to_one') {
-%>
            add<%- sortedAssociations[i].relationNameCp _%>: $add<%- sortedAssociations[i].relationNameCp _%>,
<%}}-%>
<%_for( let i=0; i<sortedAssociations.length; i++ ){
  /*
   * Render each toAdd attributes for to_many associations.
   */

  if(sortedAssociations[i].type === 'to_many' || sortedAssociations[i].type === 'to_many_through_sql_cross_table' || sortedAssociations[i].type === 'generic_to_many') {
-%>
            add<%- sortedAssociations[i].relationNameCp _%>: $add<%- sortedAssociations[i].relationNameCp _%>,
<%}}-%>
          ) {
<%if(isDefaultId){-%>
            <%- internalId _%>,
<%}-%>
<%_for( let i=0; i<attributesArr.length; i++ ){-%>
            <%- attributesArr[i][0] _%>,
<%}-%>
          } }`;

    /**
     * Debug
     */
    if(globals.REQUEST_LOGGER) logRequest('createItem', query, variables);
    return requestGraphql({ url, query, variables });
  },

<%#
/**
 * Request:
 *  Update an item (root mutation).
 * 
 * Methods:
 *   - updateItem
 * 
 */
-%>
  /**
   * updateItem
   *
   * Update <%- nameCp %> item on GraphQL Server.
   * (root mutation)
   *
   * @param {String} url GraphQL Server url.
   * @param {Object} variables Object with values to update the given <%- nameCp %> item.
   */
  updateItem(url, variables) {
    let query =
      `mutation update<%- nameCp %>(
          $<%- internalId _%>:ID!,
<%_for( let i=0; i<attributesArr.length; i++ ){
  /*
   * Render each attribute, except FK attributes and internalId.
   */

  let a = attributesArr[i][0];
  let isForeignKey = (hasOwnForeingKeys&&ownForeignKeysArr.includes(a));
  if(!isForeignKey && (attributesArr[i][0] !== internalId)) {
-%>
          $<%- attributesArr[i][0] _%>:<%- attributesArr[i][1] _%>,
<%}}-%>
<%for( let i=0; i<sortedAssociations.length; i++ ){
  /*
   * Render each toAdd & toRemove attributes for to_one associations.
   */

  if(sortedAssociations[i].type === 'to_one' || sortedAssociations[i].type === 'generic_to_one') {
-%>
          $add<%- sortedAssociations[i].relationNameCp _%>: ID,
          $remove<%- sortedAssociations[i].relationNameCp _%>: ID,
<%}}-%>
<%_for( let i=0; i<sortedAssociations.length; i++ ){
  /*
   * Render each toAdd attributes for to_many associations.
   */

  if(sortedAssociations[i].type === 'to_many' || sortedAssociations[i].type === 'to_many_through_sql_cross_table' || sortedAssociations[i].type === 'generic_to_many') {
-%>
          $add<%- sortedAssociations[i].relationNameCp _%>: [ID],
          $remove<%- sortedAssociations[i].relationNameCp _%>: [ID],
<%}}-%>
          ) { update<%- nameCp %>(
            <%- internalId _%>:$<%- internalId _%>,
<%_for( let i=0; i<attributesArr.length; i++ ){
  /*
   * Render each attribute, except FK attributes and internalId.
   */

  let a = attributesArr[i][0];
  let isForeignKey = (hasOwnForeingKeys&&ownForeignKeysArr.includes(a));
  if(!isForeignKey && (attributesArr[i][0] !== internalId)) {
-%>
            <%- attributesArr[i][0] _%>: $<%- attributesArr[i][0] _%>,
<%}}-%>
<%for( let i=0; i<sortedAssociations.length; i++ ){
  /*
   * Render each toAdd & toRemove attributes for to_one associations.
   */

  if(sortedAssociations[i].type === 'to_one' || sortedAssociations[i].type === 'generic_to_one') {
-%>
            add<%- sortedAssociations[i].relationNameCp _%>: $add<%- sortedAssociations[i].relationNameCp _%>,
            remove<%- sortedAssociations[i].relationNameCp _%>: $remove<%- sortedAssociations[i].relationNameCp _%>,
<%}}-%>
<%_for( let i=0; i<sortedAssociations.length; i++ ){
  /*
   * Render each toAdd attributes for to_many associations.
   */

  if(sortedAssociations[i].type === 'to_many' || sortedAssociations[i].type === 'to_many_through_sql_cross_table' || sortedAssociations[i].type === 'generic_to_many') {
-%>
            add<%- sortedAssociations[i].relationNameCp _%>: $add<%- sortedAssociations[i].relationNameCp _%>,
            remove<%- sortedAssociations[i].relationNameCp _%>: $remove<%- sortedAssociations[i].relationNameCp _%>,
<%}}-%>
          ) {
            <%- internalId _%>,
<%_for( let i=0; i<attributesArr.length; i++ ){
  if(attributesArr[i][0] !== internalId) {
-%>
            <%- attributesArr[i][0] _%>,
<%}}-%>
          } }`;

    /**
     * Debug
     */
    if(globals.REQUEST_LOGGER) logRequest('updateItem', query, variables);
    return requestGraphql({ url, query, variables });
  },

<%#
/**
 * Request:
 *  Delete an item (root mutation).
 * 
 * Methods:
 *   - deleteItem
 * 
 */
-%>
  /**
   * deleteItem
   *
   * Delete an item on GraphQL Server.
   * (root mutation)
   *
   * @param {String} url GraphQL Server url.
   * @param {Object} variables Object with values needed to delete the <%- nameCp %> item.
   */
  deleteItem(url, variables) {
    let query =
      `mutation 
            delete<%- nameCp %>(
              $<%- internalId _%>:ID!
        ) { delete<%- nameCp %>(
              <%- internalId _%>:$<%- internalId -%>
        ) }`

    /**
     * Debug
     */
    if(globals.REQUEST_LOGGER) logRequest('deleteItem', query, variables);
    return requestGraphql({ url, query, variables });
  },

<%#
  /**
   * Association Filters
   * 
   */
-%>
<%for( let i=0; i<sortedAssociations.length; i++ ){-%>
<%#
/**
 * Filter:
 *  Get associated items.
 * 
 * Methods:
 *   - get<sortedAssociations[i].relationNameCp>
 * 
 */
-%>
<%- include('./includes/filter-get-associated-items', {aindex: i}); %>

<%#
/**
 * Filter:
 *  Get associated count.
 * 
 * Methods:
 *   - limitOffset: get<sortedAssociations[i].relationNameCp>FilterCount
 *   - cursorBased: get<sortedAssociations[i].relationNameCp>ConnectionCount
 * 
 * -------------------------
 * 
 * Implemented for:
 *   - to_many
 *   - many_to_many
 *   - generic_to_many
 * 
 * Not apply for:
 *   - to_one
 *   - generic_to_one
 * 
 */
-%>
<%_if( sortedAssociations[i].type === 'to_many' || sortedAssociations[i].type === 'to_many_through_sql_cross_table' || sortedAssociations[i].type === 'generic_to_many'){-%>
<%- include('./includes/filter-get-associated-count', {aindex: i}); %>
<%}-%>

<%#
/**
 * Filter:
 *  Get associated ids.
 * 
 * Methods:
 *   - limitOffset: getAssociated<sortedAssociations[i].relationNameCp>
 *   - cursorBased: getAssociated<sortedAssociations[i].relationNameCp>Connection
 * 
 */
-%>
<%- include('./includes/filter-get-associated-ids', {aindex: i}); %>

<%#
/**
 * Filter:
 *  Get not associated count.
 * 
 * Methods:
 *   - getNotAssociated<sortedAssociations[i].relationNameCp>Count
 * 
 */
-%>
<%- include('./includes/filter-get-not-associated-count', {aindex: i}); %>

<%#
/**
 * Filter:
 *  Get not associated items.
 * 
 * Methods:
 *   - getNotAssociated<sortedAssociations[i].relationNameCp>
 * 
 */
-%>
<%- include('./includes/filter-get-not-associated-items', {aindex: i}); %>

<%}-%><%# //end: for() -%>


  /**
   * getItemsAttribute
   *
   * Get all items from GraphQL Server using a cursor-based-connection. Get only the indicated
   * attribute. No search, order or pagination are specified in this function, so
   * all items will be retrieved without a particular order or search filter.
   *
   * @param {String} url GraphQL Server url
   * @param {String} attribute Name of the attribute to be retrieved.
   */
  getItemsAttribute(url, attribute) {
    let query =
      `query
          { <%- namePlLc _%>Connection {
            edges {
              node {
                ${attribute}
              }
            }
          }}`;
    /**
     * Debug
     */
    if(globals.REQUEST_LOGGER) logRequest('getItemsAttribute', query);

    return requestGraphql({ url, query });

  },
}//end: export default

