<%
/**
 * variables
 */
let isToOne = ( sortedAssociations[aindex].type === 'to_one' || sortedAssociations[aindex].type === 'generic_to_one' );
let isToMany = ( sortedAssociations[aindex].type === 'to_many' || sortedAssociations[aindex].type === 'to_many_through_sql_cross_table' || sortedAssociations[aindex].type === 'generic_to_many' );
-%>
import React, { useState, useEffect, useRef, useCallback } from 'react';
import { useSelector } from 'react-redux';
import { makeStyles } from '@material-ui/core/styles';
import { blueGrey } from '@material-ui/core/colors';
import { useTranslation } from 'react-i18next';
import { useSnackbar } from 'notistack';
import Snackbar from '../../../../../../../../../../snackbar/Snackbar';
import PropTypes from 'prop-types';
import api from '../../../../../../../../../../../requests/requests.index.js';
import { makeCancelable } from '../../../../../../../../../../../utils'
import <%- sortedAssociations[aindex].relationNameOnPascal _%>ToAddTransferViewToolbar from './components/<%- sortedAssociations[aindex].relationNameCp _%>ToAddTransferViewToolbar';
<%if(sortedAssociations[aindex].paginationType === 'cursorBased') {-%>
import <%- sortedAssociations[aindex].relationNameOnPascal _%>ToAddTransferViewCursorPagination from './components/<%- sortedAssociations[aindex].relationNameCp _%>ToAddTransferViewCursorPagination';
<%} else if(sortedAssociations[aindex].paginationType === 'limitOffset') {-%>
import TablePagination from '@material-ui/core/TablePagination';
<%}-%>
import Typography from '@material-ui/core/Typography';
import Grid from '@material-ui/core/Grid';
import Box from '@material-ui/core/Box';
import Card from '@material-ui/core/Card';
import CircularProgress from '@material-ui/core/CircularProgress';
import List from '@material-ui/core/List';
import ListItem from '@material-ui/core/ListItem';
import ListItemText from '@material-ui/core/ListItemText';
import ListItemAvatar from '@material-ui/core/ListItemAvatar';
import ListItemSecondaryAction from '@material-ui/core/ListItemSecondaryAction';
import Avatar from '@material-ui/core/Avatar';
import Hidden from '@material-ui/core/Hidden';
import Fade from '@material-ui/core/Fade';
import Button from '@material-ui/core/Button';
import IconButton from '@material-ui/core/IconButton';
import Tooltip from '@material-ui/core/Tooltip';
import Add from '@material-ui/icons/AddCircle';
import Remove from '@material-ui/icons/RemoveCircle';
import TransferArrows from '@material-ui/icons/SettingsEthernetOutlined';
import Key from '@material-ui/icons/VpnKey';

const useStyles = makeStyles(theme => ({
  root: {
    margin: theme.spacing(0),
    [theme.breakpoints.down('xs')]: {
      minWidth: 200,
    },
    [theme.breakpoints.up('sm')]: {
      minWidth: 910,
    },
  },
  container: {
    margin: theme.spacing(0),
  },
  card: {
    margin: theme.spacing(0),
    height: 'auto',
    maxHeight: `calc(64vh + 52px)`,
    overflow: 'auto',
    position: "relative",
  },
  listBox: {
    height: 'auto',
    minHeight: 82,
    maxHeight: '33vh',
    overflowY: 'auto',
    overflowX: 'hidden'
  },
  noDataBox: {
    width: "100%",
    height: 'auto',
    minHeight: 82,
    maxHeight: '33vh',
  },
  loadingBox: {
    width: "100%",
    height: '100%',
    maxHeight: '33vh',
  },
  arrowsBox: {
    [theme.breakpoints.down('xs')]: {
      marginTop: theme.spacing(0),
    
    },
    [theme.breakpoints.up('sm')]: {
      marginTop: theme.spacing(3),
    },
  },
  arrowsV: {
    transform: "rotate(90deg)",
  },
  row: {
    maxHeight: 70,
  },
}));

export default function <%- sortedAssociations[aindex].relationNameOnPascal _%>ToAddTransferView(props) {
  const classes = useStyles();
  const { t } = useTranslation();
  const { enqueueSnackbar, closeSnackbar } = useSnackbar();
  const {
    idsToAdd,
    handleTransfer,
    handleUntransfer,
    handleClickOn<%- sortedAssociations[aindex].targetModelCp _%>Row,
  } = props;

  /*
    State A (selectable list)
  */
  const [items, setItems] = useState([]);
  const [count, setCount] = useState(-1);
  const [search, setSearch] = useState('');
  const [page, setPage] = useState(0);
  const [rowsPerPage, setRowsPerPage] = useState(10);
  const [isOnApiRequest, setIsOnApiRequest] = useState(false);
  const [areItemsReady, setAreItemsReady] = useState(false);
  const [dataTrigger, setDataTrigger] = useState(false);
  const isPendingApiRequestRef = useRef(false);
  const isOnApiRequestRef = useRef(false);
  const isGettingFirstDataRef = useRef(true);
  const pageRef = useRef(0);
  const rowsPerPageRef = useRef(10);
  const lastFetchTime = useRef(null);
<%if(sortedAssociations[aindex].paginationType === 'limitOffset') {-%>
  const [isCounting, setIsCounting] = useState(true);
<%}-%>
  const isCountingRef = useRef(false);
<%if(sortedAssociations[aindex].paginationType === 'cursorBased') {-%>
  const [hasPreviousPage, setHasPreviousPage] = useState(false);
  const [hasNextPage, setHasNextPage] = useState(false);
  const pageInfo = useRef({startCursor: null, endCursor: null, hasPreviousPage: false, hasNextPage: false});
  const paginationRef = useRef({first: rowsPerPage, after: null, last: null, before: null, includeCursor: false});
  const isForwardPagination = useRef(true);
  const isCursorPaginating = useRef(false);
<%}-%>
const cancelableCountingPromises = useRef([]);

  /*
    State B (to add list)
  */
  const [itemsB, setItemsB] = useState([]);
<%_if( isToMany ){-%>
  const [countB, setCountB] = useState(-1);
<%}-%>
  const [searchB, setSearchB] = useState('');
  const [pageB, setPageB] = useState(0);
<%_if( isToMany ){-%>
  const [rowsPerPageB, setRowsPerPageB] = useState(10);
<%}-%>
  const [isOnApiRequestB, setIsOnApiRequestB] = useState(false);
  const [areItemsReadyB, setAreItemsReadyB] = useState(false);
  const [dataTriggerB, setDataTriggerB] = useState(false);
  const isPendingApiRequestRefB = useRef(false);
  const isOnApiRequestRefB = useRef(false);
  const isGettingFirstDataRefB = useRef(true);
  const pageRefB = useRef(0);
<%_if( isToMany ){-%>
  const rowsPerPageRefB = useRef(10);
<%}-%>
  const lastFetchTimeB = useRef(null);
<%_if( isToMany ){-%>
<%if(sortedAssociations[aindex].paginationType === 'limitOffset') {-%>
  const [isCountingB, setIsCountingB] = useState(true);
<%}-%>
  const isCountingRefB = useRef(false);
<%if(sortedAssociations[aindex].paginationType === 'cursorBased') {-%>
  const [hasPreviousPageB, setHasPreviousPageB] = useState(false);
  const [hasNextPageB, setHasNextPageB] = useState(false);
  const pageInfoB = useRef({startCursor: null, endCursor: null, hasPreviousPage: false, hasNextPage: false});
  const paginationRefB = useRef({first: rowsPerPage, after: null, last: null, before: null, includeCursor: false});
  const isForwardPaginationB = useRef(true);
  const isCursorPaginatingB = useRef(false);
<%}-%>
  const cancelableCountingPromisesB = useRef([]);
<%}-%>

  const [thereAreItemsToAdd, setThereAreItemsToAdd] = useState((idsToAdd && Array.isArray(idsToAdd) && idsToAdd.length > 0));
  const lidsToAdd = useRef((idsToAdd && Array.isArray(idsToAdd)) ? Array.from(idsToAdd) : []);

  const cancelablePromises = useRef([]);

  const graphqlServerUrl = useSelector(state => state.urls.graphqlServerUrl)
  const lastModelChanged = useSelector(state => state.changes.lastModelChanged);
  const lastChangeTimestamp = useSelector(state => state.changes.lastChangeTimestamp);

  const lref = useRef(null);
  const lrefB = useRef(null);
  const [lh, setLh] = useState(82);
  const [lhB, setLhB] = useState(82);

  //snackbar
  const variant = useRef('info');
  const errors = useRef([]);
  const content = useRef((key, message) => (
    <Snackbar id={key} message={message} errors={errors.current}
    variant={variant.current} />
  ));
  const actionText = useRef(t('modelPanels.gotIt', "Got it"));
  const action = useRef((key) => (
    <>
      <Button color='inherit' variant='text' size='small' 
      onClick={() => { closeSnackbar(key) }}>
        {actionText.current}
      </Button>
    </> 
  ));

  //snackbar
  const variantB = useRef('info');
  const errorsB = useRef([]);
  const contentB = useRef((key, message) => (
    <Snackbar id={key} message={message} errors={errorsB.current}
    variant={variantB.current} />
  ));
  const actionTextB = useRef(t('modelPanels.gotIt', "Got it"));
  const actionB = useRef((key) => (
    <>
      <Button color='inherit' variant='text' size='small' 
      onClick={() => { closeSnackbar(key) }}>
        {actionTextB.current}
      </Button>
    </> 
  ));

  //snackbar (for: getCount)
  const variantC = useRef('info');
  const errorsC = useRef([]);
  const contentC = useRef((key, message) => (
    <Snackbar id={key} message={message} errors={errorsC.current}
    variant={variantC.current} />
  ));
  const actionTextC = useRef(t('modelPanels.gotIt', "Got it"));
  const actionC = useRef((key) => (
    <>
      <Button color='inherit' variant='text' size='small' 
      onClick={() => { closeSnackbar(key) }}>
        {actionTextC.current}
      </Button>
    </> 
  ));

<%_if( isToMany ){-%>
  //snackbar (for: getCountB)
  const variantD = useRef('info');
  const errorsD = useRef([]);
  const contentD = useRef((key, message) => (
    <Snackbar id={key} message={message} errors={errorsD.current}
    variant={variantD.current} />
  ));
  const actionTextD = useRef(t('modelPanels.gotIt', "Got it"));
  const actionD = useRef((key) => (
    <>
      <Button color='inherit' variant='text' size='small' 
      onClick={() => { closeSnackbar(key) }}>
        {actionTextD.current}
      </Button>
    </> 
  ));
<%}-%>

  /**
    * Callbacks:
    *  showMessage
    *  showMessageB
    *  showMessageC
<%_if( isToMany ){-%>
    *  showMessageD
<%}-%>
<%if(sortedAssociations[aindex].paginationType === 'cursorBased') {-%>
    *  configurePagination
<%}-%>
<%if(sortedAssociations[aindex].paginationType === 'cursorBased' && isToMany) {-%>
    *  configurePaginationB
<%}-%>
    *  clearRequestGetData
    *  clearRequestGetDataB
    *  getCount
<%_if( isToMany ){-%>
    *  getCountB
<%}-%>
    *  getData
    *  getDataB
    */

  /**
   * showMessage
   * 
   * Show the given message in a notistack snackbar.
   * 
   */
  const showMessage = useCallback((message, withDetail) => {
    enqueueSnackbar( message, {
      variant: variant.current,
      preventDuplicate: false,
      persist: true,
      action: !withDetail ? action.current : undefined,
      content: withDetail ? content.current : undefined,
    });
  },[enqueueSnackbar]);

  /**
   * showMessageB
   * 
   * Show the given message in a notistack snackbar.
   * 
   */
  const showMessageB = useCallback((message, withDetail) => {
    enqueueSnackbar( message, {
      variant: variantB.current,
      preventDuplicate: false,
      persist: true,
      action: !withDetail ? actionB.current : undefined,
      content: withDetail ? contentB.current : undefined,
    });
  },[enqueueSnackbar]);

  /**
   * showMessageC
   * 
   * Show the given message in a notistack snackbar.
   * 
   */
  const showMessageC = useCallback((message, withDetail) => {
    enqueueSnackbar( message, {
      variant: variantC.current,
      preventDuplicate: false,
      persist: true,
      action: !withDetail ? actionC.current : undefined,
      content: withDetail ? contentC.current : undefined,
    });
  },[enqueueSnackbar]);

<%_if( isToMany ){-%>
  /**
   * showMessageD
   * 
   * Show the given message in a notistack snackbar.
   * 
   */
  const showMessageD = useCallback((message, withDetail) => {
    enqueueSnackbar( message, {
      variant: variantD.current,
      preventDuplicate: false,
      persist: true,
      action: !withDetail ? actionD.current : undefined,
      content: withDetail ? contentD.current : undefined,
    });
  },[enqueueSnackbar]);
<%}-%>

<%if(sortedAssociations[aindex].paginationType === 'cursorBased') {-%>
  /**
   * configurePagination
   * 
   * Set the configuration needed to perform a reload of data
   * in the given mode.
   */
  const configurePagination = useCallback((mode) => {
    switch(mode) {
      case "reset":
        //reset page info attributes
        pageInfo.current = {startCursor: null, endCursor: null, hasPreviousPage: false, hasNextPage: false};
        //set direction
        isForwardPagination.current = true;
        //set pagination attributes
        paginationRef.current = {
          first: rowsPerPageRef.current,
          after: null,
          last: null,
          before: null,
          includeCursor: false,
        }
        break;
      
      case "reload":
        //set direction
        isForwardPagination.current = true;
        //set pagination attributes
        paginationRef.current = {
          first: rowsPerPageRef.current,
          after: pageInfo.current.startCursor,
          last: null,
          before: null,
          includeCursor: true,
        }
        break;

      case "firstPage":
        //set direction
        isForwardPagination.current = true;
        //set pagination attributes
        paginationRef.current = {
          first: rowsPerPageRef.current,
          after: null,
          last: null,
          before: null,
          includeCursor: false,
        }
        break;

      case "lastPage":
        //set direction
        isForwardPagination.current = false;
        //set pagination attributes
        paginationRef.current = {
          first: null,
          after: null,
          last: rowsPerPageRef.current,
          before: null,
          includeCursor: false,
        }
        break;

      case "nextPage":
        //set direction
        isForwardPagination.current = true;
        //set pagination attributes
        paginationRef.current = {
          first: rowsPerPageRef.current,
          after: pageInfo.current.endCursor,
          last: null,
          before: null,
          includeCursor: false,
        }
        break;

      case "previousPage":
        //set direction
        isForwardPagination.current = false;
        //set pagination attributes
        paginationRef.current = {
          first: null,
          after: null,
          last: rowsPerPageRef.current,
          before: pageInfo.current.startCursor,
          includeCursor: false,
        }
        break;

      default: //reset
        //reset page info attributes
        pageInfo.current = {startCursor: null, endCursor: null, hasPreviousPage: false, hasNextPage: false};
        //set direction
        isForwardPagination.current = true;
        //set pagination attributes
        paginationRef.current = {
          first: rowsPerPageRef.current,
          after: null,
          last: null,
          before: null,
          includeCursor: false,
        }
        break;
    }
  }, []);
<%}-%>

<%_if( isToMany ){-%>
<%if(sortedAssociations[aindex].paginationType === 'cursorBased') {-%>
  /**
   * configurePaginationB
   * 
   * Set the configuration needed to perform a reload of data
   * in the given mode.
   */
  const configurePaginationB = useCallback((mode) => {
    switch(mode) {
      case "reset":
        //reset page info attributes
        pageInfoB.current = {startCursor: null, endCursor: null, hasPreviousPage: false, hasNextPage: false};
        //set direction
        isForwardPaginationB.current = true;
        //set pagination attributes
        paginationRefB.current = {
          first: rowsPerPageRefB.current,
          after: null,
          last: null,
          before: null,
          includeCursor: false,
        }
        break;
      
      case "reload":
        //set direction
        isForwardPaginationB.current = true;
        //set pagination attributes
        paginationRefB.current = {
          first: rowsPerPageRefB.current,
          after: pageInfoB.current.startCursor,
          last: null,
          before: null,
          includeCursor: true,
        }
        break;

      case "firstPage":
        //set direction
        isForwardPaginationB.current = true;
        //set pagination attributes
        paginationRefB.current = {
          first: rowsPerPageRefB.current,
          after: null,
          last: null,
          before: null,
          includeCursor: false,
        }
        break;

      case "lastPage":
        //set direction
        isForwardPaginationB.current = false;
        //set pagination attributes
        paginationRefB.current = {
          first: null,
          after: null,
          last: rowsPerPageRefB.current,
          before: null,
          includeCursor: false,
        }
        break;

      case "nextPage":
        //set direction
        isForwardPaginationB.current = true;
        //set pagination attributes
        paginationRefB.current = {
          first: rowsPerPageRefB.current,
          after: pageInfoB.current.endCursor,
          last: null,
          before: null,
          includeCursor: false,
        }
        break;

      case "previousPage":
        //set direction
        isForwardPaginationB.current = false;
        //set pagination attributes
        paginationRefB.current = {
          first: null,
          after: null,
          last: rowsPerPageRefB.current,
          before: pageInfoB.current.startCursor,
          includeCursor: false,
        }
        break;

      default: //reset
        //reset page info attributes
        pageInfoB.current = {startCursor: null, endCursor: null, hasPreviousPage: false, hasNextPage: false};
        //set direction
        isForwardPaginationB.current = true;
        //set pagination attributes
        paginationRefB.current = {
          first: rowsPerPageRefB.current,
          after: null,
          last: null,
          before: null,
          includeCursor: false,
        }
        break;
    }
  }, []);
<%}-%>
<%}-%>

  const clearRequestGetData = useCallback(() => {
<%if(sortedAssociations[aindex].paginationType === 'cursorBased') {-%>
    //configure pagination
    configurePagination('reset');
<%}-%>          
    setItems([]);
    isOnApiRequestRef.current = false;
    setIsOnApiRequest(false);
  },[<%if(sortedAssociations[aindex].paginationType === 'cursorBased') {-%>configurePagination<%}-%>]);

  const clearRequestGetDataB = useCallback(() => {
<%if(sortedAssociations[aindex].paginationType === 'cursorBased' && isToMany) {-%>
    //configure pagination
    configurePaginationB('reset');
<%}-%>  
    setItemsB([]);
    isOnApiRequestRefB.current = false;
    setIsOnApiRequestB(false);
  },[<%if(sortedAssociations[aindex].paginationType === 'cursorBased' && isToMany) {-%>configurePaginationB<%}-%>]);

<%
  /**
   * names
   */
  let methodName5 = 'getCount()';
  let queryName5 = 'count'+sortedAssociations[aindex].targetModelPlCp;
  let requestName5 = 'api.'+sortedAssociations[aindex].targetModelLc+'.getCountItems'
-%>
  /**
   * getCount
   * 
   * Get @count from GrahpQL Server.
   * Uses current state properties to fill query request.
   * Updates state to inform new @count retreived.
   * 
   */
  const getCount = useCallback(async () => {
    //return if there is an active count operation
    if(isCountingRef.current) return;

    cancelCountingPromises();
<%if(sortedAssociations[aindex].paginationType === 'limitOffset') {-%>
    setIsCounting(true);
<%}-%>
    isCountingRef.current = true;
    errorsC.current = [];

    let c1 = makeCancelable( new Promise(resolve => {
      //set timeout
      window.setTimeout(function() {
        resolve("ok");
      }, 3000);
    }));
    cancelableCountingPromises.current.push(c1);
    await c1
      .promise
      .then(
      //resolved
      (response) => {
        //delete from cancelables
        cancelableCountingPromises.current.splice(cancelableCountingPromises.current.indexOf(c1), 1);
      },
      (err) => {
        console.log("c1.rejected: err - timeout:", err);
        if(err.isCanceled) return;
        else throw err;
      })
      //error
      .catch((err) => { //error: on api.individual.getCountItems
        console.log("c1.catch: err - timeout:", err);
        if(err.isCanceled) return;
        else throw err;
      });

    let ops = null;
    if(lidsToAdd.current && lidsToAdd.current.length > 0) {
      ops = {
        exclude: [{
          type: '<%- sortedAssociations[aindex].internalIdType _%>',
          values: {"<%- sortedAssociations[aindex].internalId _%>": lidsToAdd.current}
        }]
      };
    }    

    /*
      API Request: <%- queryName5 %>
    */
    let cancelableApiReq = makeCancelable(api.<%- sortedAssociations[aindex].targetModelLc _%>.getCountItems(graphqlServerUrl, search, ops));
    cancelableCountingPromises.current.push(cancelableApiReq);
    await cancelableApiReq
      .promise
      .then(
      //resolved
      (response) => {
        //delete from cancelables
        cancelableCountingPromises.current.splice(cancelableCountingPromises.current.indexOf(cancelableApiReq), 1);
        
        //check: response data
        if(!response.data ||!response.data.data) {
          let newError = {};
          let withDetails=true;
          variantC.current='error';
          newError.message = t('modelPanels.errors.data.e1', 'No data was received from the server.');
          newError.locations=[{model: '<%- name -%>', association: '<%- sortedAssociations[aindex].relationName _%>', table:'A', query: '<%- queryName5 %>', method: '<%- methodName5 %>', request: '<%- requestName5 %>'}];
          newError.path=['add', '<%- sortedAssociations[aindex].relationName _%>'];
          newError.extensions = {graphqlResponse:{data:response.data.data, errors:response.data.errors}};
          errorsC.current.push(newError);
          console.log("Error: ", newError);

          showMessageC(newError.message, withDetails);
          return;
        }

        //check: <%- queryName5 %>
        let <%- queryName5 %> = response.data.data["<%- queryName5 %>"];
        if(<%- queryName5 %> === null) {
          let newError = {};
          let withDetails=true;
          variantC.current='error';
          newError.message = '<%- queryName5 %> ' + t('modelPanels.errors.data.e2', 'could not be fetched.');
          newError.locations=[{model: '<%- name -%>', association: '<%- sortedAssociations[aindex].relationName _%>', table:'A', query: '<%- queryName5 %>', method: '<%- methodName5 %>', request: '<%- requestName5 %>'}];
          newError.path=['add', '<%- sortedAssociations[aindex].relationName _%>'];
          newError.extensions = {graphqlResponse:{data:response.data.data, errors:response.data.errors}};
          errorsC.current.push(newError);
          console.log("Error: ", newError);

          showMessageC(newError.message, withDetails);
          return;
        }

        //check: <%- queryName5 %> type
        if(!Number.isInteger(<%- queryName5 %>)) {
          let newError = {};
          let withDetails=true;
          variantC.current='error';
          newError.message = '<%- queryName5 %> ' + t('modelPanels.errors.data.e4', ' received, does not have the expected format.');
          newError.locations=[{model: '<%- name -%>', association: '<%- sortedAssociations[aindex].relationName _%>', table:'A', query: '<%- queryName5 %>', method: '<%- methodName5 %>', request: '<%- requestName5 %>'}];
          newError.path=['add', '<%- sortedAssociations[aindex].relationName _%>'];
          newError.extensions = {graphqlResponse:{data:response.data.data, errors:response.data.errors}};
          errorsC.current.push(newError);
          console.log("Error: ", newError);

          showMessageC(newError.message, withDetails);
          return;
        }

        //ok
        setCount(<%- queryName5 %>);
<%if(sortedAssociations[aindex].paginationType === 'limitOffset') {-%>
        setIsCounting(false);
<%}-%>
        isCountingRef.current = false;

        //check: graphql errors
        if(response.data.errors) {
          let newError = {};
          let withDetails=true;
          variantC.current='info';
          newError.message = '<%- queryName5 %> ' + t('modelPanels.errors.data.e3', 'fetched with errors.');
          newError.locations=[{association: '<%- sortedAssociations[aindex].relationName _%>', query: '<%- queryName5 %>', method: '<%- methodName5 %>', request: '<%- requestName5 %>'}];
          newError.path=['add', '<%- sortedAssociations[aindex].relationName _%>'];
          newError.extensions = {graphQL:{data:response.data.data, errors:response.data.errors}};
          errorsC.current.push(newError);
          console.log("Error: ", newError);

          showMessageC(newError.message, withDetails);
        }
       
<%if(sortedAssociations[aindex].paginationType === 'limitOffset') {-%>
        /*
          Check: empty page
        */
        if( (<%- queryName5 %> === (pageRef.current * rowsPerPageRef.current)) && (pageRef.current > 0) ) 
        {
          isOnApiRequestRef.current = false;
          setIsOnApiRequest(false);
          setPage(pageRef.current - 1);
          return;
        }

        /*
          Check: page overflow
        */
        if((pageRef.current * rowsPerPageRef.current) > <%- queryName5 %>) {
          isOnApiRequestRef.current = false;
          setIsOnApiRequest(false);
          setPage(Math.floor(<%- queryName5 %> / rowsPerPageRef.current));
          return;
        }

<%}-%>
      },
      //rejected
      (err) => {
        if(err.isCanceled) return;
        else throw err;
      })
      //error
      .catch((err) => { //error: on <%- requestName5 %>
        if(err.isCanceled) {
          return;
        } else {
          let newError = {};
          let withDetails=true;
          variantC.current='error';
          newError.message = t('modelPanels.errors.request.e1', 'Error in request made to server.');
          newError.locations=[{model: '<%- name -%>', association: '<%- sortedAssociations[aindex].relationName _%>', table:'A', query: '<%- queryName5 %>', method: '<%- methodName5 %>', request: '<%- requestName5 %>'}];
          newError.path=['add', '<%- sortedAssociations[aindex].relationName _%>'];
          newError.extensions = {error:{message:err.message, name:err.name, response:err.response}};
          errorsC.current.push(newError);
          console.log("Error: ", newError);

          showMessageC(newError.message, withDetails);
          return;
        }
      });
  }, [graphqlServerUrl, showMessageC, t, search]);

<%
  /**
   * names
   */
  let methodName1 = 'getData()';
  let queryName1 = sortedAssociations[aindex].paginationType === 'limitOffset' ? sortedAssociations[aindex].targetModelPlLc : sortedAssociations[aindex].targetModelPlLc+'Connection';
  let requestName1 =  sortedAssociations[aindex].paginationType === 'limitOffset' ? 'api.'+sortedAssociations[aindex].targetModelLc+'.getItems' : 'api.'+sortedAssociations[aindex].targetModelLc+'.getItemsConnection';
-%>
  /**
   * getData
   * 
   * Get @items from GrahpQL Server.
   * Uses current state properties to fill query request.
   * Updates state to inform new @items retreived.
   * 
   */
  const getData = useCallback(() => {
    updateHeights();
    isOnApiRequestRef.current = true;
    setIsOnApiRequest(true);
    Boolean(dataTrigger); //avoid warning
    errors.current = [];

    //count (async)
    getCount();

    let ops = null;
    if(lidsToAdd.current && lidsToAdd.current.length > 0) {
      ops = {
        exclude: [{
          type: '<%- sortedAssociations[aindex].internalIdType _%>',
          values: {"<%- sortedAssociations[aindex].internalId _%>": lidsToAdd.current}
        }]
      };
    }    

<%if(sortedAssociations[aindex].paginationType === 'limitOffset') {-%>
    /*
      API Request: <%- queryName1 %>
    */
    let cancelableApiReqB = makeCancelable(api.<%- sortedAssociations[aindex].targetModelLc _%>.getItems(
      graphqlServerUrl,
      search,
      null, //orderBy
      null, //orderDirection
      pageRef.current * rowsPerPageRef.current, //paginationOffset
      rowsPerPageRef.current, //paginationLimit
      ops
    ));
<%} else if(sortedAssociations[aindex].paginationType === 'cursorBased') {-%>
    /*
      API Request: <%- queryName1 %>
    */
    let variables = {
      pagination: {...paginationRef.current}
    };
    let cancelableApiReqB = makeCancelable(api.<%- sortedAssociations[aindex].targetModelLc _%>.getItemsConnection(
      graphqlServerUrl,
      search,
      null, //orderBy
      null, //orderDirection
      variables,
      ops
    ));
<%}-%>
    cancelablePromises.current.push(cancelableApiReqB);
    cancelableApiReqB
      .promise
      .then(
      //resolved
      (response) => {
        //delete from cancelables
        cancelablePromises.current.splice(cancelablePromises.current.indexOf(cancelableApiReqB), 1);
        
        //check: response data
        if(!response.data ||!response.data.data) {
          let newError = {};
          let withDetails=true;
          variant.current='error';
          newError.message = t('modelPanels.errors.data.e1', 'No data was received from the server.');
          newError.locations=[{model: '<%- name -%>', association: '<%- sortedAssociations[aindex].relationName _%>', table:'A', query: '<%- queryName1 %>', method: '<%- methodName1 %>', request: '<%- requestName1 %>'}];
          newError.path=['add', '<%- sortedAssociations[aindex].relationName _%>'];
          newError.extensions = {graphqlResponse:{data:response.data.data, errors:response.data.errors}};
          errors.current.push(newError);
          console.log("Error: ", newError);

          showMessage(newError.message, withDetails);
          clearRequestGetData();
          return;
        }

        //check: <%- queryName1 %>
        let <%- queryName1 %> = response.data.data.<%- queryName1 %>;
        if(<%- queryName1 %> === null) {
          let newError = {};
          let withDetails=true;
          variant.current='error';
          newError.message = '<%- queryName1 %> ' + t('modelPanels.errors.data.e2', 'could not be fetched.');
          newError.locations=[{model: '<%- name -%>', association: '<%- sortedAssociations[aindex].relationName _%>', table:'A', query: '<%- queryName1 %>', method: '<%- methodName1 %>', request: '<%- requestName1 %>'}];
          newError.path=['add', '<%- sortedAssociations[aindex].relationName _%>'];
          newError.extensions = {graphqlResponse:{data:response.data.data, errors:response.data.errors}};
          errors.current.push(newError);
          console.log("Error: ", newError);

          showMessage(newError.message, withDetails);
          clearRequestGetData();
          return;
        }

<%if(sortedAssociations[aindex].paginationType === 'limitOffset') {-%>
        //check: <%- queryName1 %> type
        if(!Array.isArray(<%- queryName1 %>)) {
          let newError = {};
          let withDetails=true;
          variant.current='error';
          newError.message = '<%- queryName1 %> ' + t('modelPanels.errors.data.e4', ' received, does not have the expected format.');
          newError.locations=[{model: '<%- name -%>', association: '<%- sortedAssociations[aindex].relationName _%>', table:'A', query: '<%- queryName1 %>', method: '<%- methodName1 %>', request: '<%- requestName1 %>'}];
          newError.path=['add', '<%- sortedAssociations[aindex].relationName _%>'];
          newError.extensions = {graphqlResponse:{data:response.data.data, errors:response.data.errors}};
          errors.current.push(newError);
          console.log("Error: ", newError);

          showMessage(newError.message, withDetails);
          clearRequestGetData();
          return;
        }
        //get items
        let its = <%- queryName1 %>;

        //check: graphql errors
        if(response.data.errors) {
          let newError = {};
          let withDetails=true;
          variant.current='info';
          newError.message = '<%- queryName1 %> ' + t('modelPanels.errors.data.e3', 'fetched with errors.');
          newError.locations=[{model: '<%- name -%>', association: '<%- sortedAssociations[aindex].relationName _%>', table:'A', query: '<%- queryName1 %>', method: '<%- methodName1 %>', request: '<%- requestName1 %>'}];
          newError.path=['add', '<%- sortedAssociations[aindex].relationName _%>'];
          newError.extensions = {graphQL:{data:response.data.data, errors:response.data.errors}};
          errors.current.push(newError);
          console.log("Error: ", newError);

          showMessage(newError.message, withDetails);
        }

<%} else if(sortedAssociations[aindex].paginationType === 'cursorBased') {-%>
        //check: <%- queryName1 %> type
        if(typeof <%- queryName1 %> !== 'object'
        || !Array.isArray(<%- queryName1 %>.edges)
        || typeof <%- queryName1 %>.pageInfo !== 'object' 
        || <%- queryName1 %>.pageInfo === null) {
          let newError = {};
          let withDetails=true;
          variant.current='error';
          newError.message = '<%- queryName1 %> ' + t('modelPanels.errors.data.e4', ' received, does not have the expected format.');
          newError.locations=[{model: '<%- name -%>', association: '<%- sortedAssociations[aindex].relationName _%>', table:'A', query: '<%- queryName1 %>', method: '<%- methodName1 %>', request: '<%- requestName1 %>'}];
          newError.path=['add', '<%- sortedAssociations[aindex].relationName _%>'];
          newError.extensions = {graphqlResponse:{data:response.data.data, errors:response.data.errors}};
          errors.current.push(newError);
          console.log("Error: ", newError);

          showMessage(newError.message, withDetails);
          clearRequestGetData();
          return;
        }
        //get items
        let its = <%- queryName1 %>.edges.map(o => o.node);
        let pi = <%- queryName1 %>.pageInfo;

        //check: graphql errors
        if(response.data.errors) {
          let newError = {};
          let withDetails=true;
          variant.current='info';
          newError.message = '<%- queryName1 %> ' + t('modelPanels.errors.data.e3', 'fetched with errors.');
          newError.locations=[{model: '<%- name -%>', association: '<%- sortedAssociations[aindex].relationName _%>', table:'A', query: '<%- queryName1 %>', method: '<%- methodName1 %>', request: '<%- requestName1 %>'}];
          newError.path=['add', '<%- sortedAssociations[aindex].relationName _%>'];
          newError.extensions = {graphQL:{data:response.data.data, errors:response.data.errors}};
          errors.current.push(newError);
          console.log("Error: ", newError);

          showMessage(newError.message, withDetails);
        }

        /*
          Check: empty page
        */
        if( its.length === 0 && pi && pi.hasPreviousPage ) 
        {
          //configure
          isOnApiRequestRef.current = false;
          isCursorPaginating.current = false;
          setIsOnApiRequest(false);
          configurePagination('previousPage');
          
          //reload
          setDataTrigger(prevDataTrigger => !prevDataTrigger);
          return;
        }//else

        //update pageInfo
        pageInfo.current = pi;
        setHasPreviousPage(pageInfo.current.hasPreviousPage);
        setHasNextPage(pageInfo.current.hasNextPage);

        //configure pagination (default)
        configurePagination('reload');
<%}-%>

        //ok
        setItems([...its]);

        //ends request
        isOnApiRequestRef.current = false;
<%if(sortedAssociations[aindex].paginationType === 'cursorBased') {-%>
        isCursorPaginating.current = false;
<%}-%>
        setIsOnApiRequest(false);

        return;

      },
      //rejected
      (err) => {
        if(err.isCanceled) return;
        else throw err;
      })
      //error
      .catch((err) => { //error: on <%- requestName1 %>
        if(err.isCanceled) {
          return;
        } else {
          let newError = {};
          let withDetails=true;
          variant.current='error';
          newError.message = t('modelPanels.errors.request.e1', 'Error in request made to server.');
          newError.locations=[{model: '<%- name -%>', association: '<%- sortedAssociations[aindex].relationName _%>', table:'A', query: '<%- queryName1 %>', method: '<%- methodName1 %>', request: '<%- requestName1 %>'}];
          newError.path=['add', '<%- sortedAssociations[aindex].relationName _%>'];
          newError.extensions = {error:{message:err.message, name:err.name, response:err.response}};
          errors.current.push(newError);
          console.log("Error: ", newError);

          showMessage(newError.message, withDetails);
          clearRequestGetData();
          return;
        }
      });
  }, [graphqlServerUrl, showMessage, clearRequestGetData, getCount, t, dataTrigger, search<%if(sortedAssociations[aindex].paginationType === 'cursorBased') {-%>, configurePagination<%}-%>]);

<%_if( isToMany ){-%>
<%
  /**
   * names
   */
  let methodName6 = 'getCountB()';
  let queryName6 = 'count'+sortedAssociations[aindex].targetModelPlCp;
  let requestName6 = 'api.'+sortedAssociations[aindex].targetModelLc+'.getCountItems'
-%>
  /**
   * getDataB
   * 
   * Get @count from GrahpQL Server.
   * Uses current state properties to fill query request.
   * Updates state to inform new @count retreived.
   * 
   */
  const getCountB = useCallback(async () => {
    //return if there is an active count operation
    if(isCountingRefB.current) return;

    cancelCountingPromisesB();
<%if(sortedAssociations[aindex].paginationType === 'limitOffset') {-%>
    setIsCountingB(true);
<%}-%>
    isCountingRefB.current = true;
    errorsD.current = [];

    let c1 = makeCancelable( new Promise(resolve => {
      //set timeout
      window.setTimeout(function() {
        resolve("ok");
      }, 3000);
    }));
    cancelableCountingPromisesB.current.push(c1);
    await c1
      .promise
      .then(
      //resolved
      (response) => {
        //delete from cancelables
        cancelableCountingPromisesB.current.splice(cancelableCountingPromisesB.current.indexOf(c1), 1);
      },
      (err) => {
        console.log("c1.rejected: err - timeout:", err);
        if(err.isCanceled) return;
        else throw err;
      })
      //error
      .catch((err) => { //error: on api.individual.getCountItems
        console.log("c1.catch: err - timeout:", err);
        if(err.isCanceled) return;
        else throw err;
      });

    //set ops: only ids
    let ops = null;
    if(lidsToAdd.current && lidsToAdd.current.length > 0) {
      ops = {
        only: [{
          type: '<%- sortedAssociations[aindex].internalIdType _%>',
          values: {"<%- sortedAssociations[aindex].internalId _%>": lidsToAdd.current}
        }]
      };
    } else {
<%if(sortedAssociations[aindex].paginationType === 'limitOffset') {-%>
      setIsCountingB(false);
<%}-%>
      isCountingRefB.current = false;
      return;
    }

    /*
      API Request: <%- queryName6 %>
    */
    let cancelableApiReq = makeCancelable(api.<%- sortedAssociations[aindex].targetModelLc _%>.getCountItems(graphqlServerUrl, searchB, ops));
    cancelableCountingPromisesB.current.push(cancelableApiReq);
    await cancelableApiReq
      .promise
      .then(
      //resolved
      (response) => {
        //delete from cancelables
        cancelableCountingPromisesB.current.splice(cancelableCountingPromisesB.current.indexOf(cancelableApiReq), 1);
        
        //check: response data
        if(!response.data ||!response.data.data) {
          let newError = {};
          let withDetails=true;
          variantD.current='error';
          newError.message = t('modelPanels.errors.data.e1', 'No data was received from the server.');
          newError.locations=[{model: '<%- name -%>', association: '<%- sortedAssociations[aindex].relationName _%>', table:'B', query: '<%- queryName6 %>', method: '<%- methodName6 %>', request: '<%- requestName6 %>'}];
          newError.path=['add', '<%- sortedAssociations[aindex].relationName _%>'];
          newError.extensions = {graphqlResponse:{data:response.data.data, errors:response.data.errors}};
          errorsD.current.push(newError);
          console.log("Error: ", newError);

          showMessageD(newError.message, withDetails);
          return;
        }

        //check: <%- queryName6 %>
        let <%- queryName6 %> = response.data.data.<%- queryName6 %>;
        if(<%- queryName6 %> === null) {
          let newError = {};
          let withDetails=true;
          variantD.current='error';
          newError.message = '<%- queryName6 %> ' + t('modelPanels.errors.data.e2', 'could not be fetched.');
          newError.locations=[{model: '<%- name -%>', association: '<%- sortedAssociations[aindex].relationName _%>', table:'B', query: '<%- queryName6 %>', method: '<%- methodName6 %>', request: '<%- requestName6 %>'}];
          newError.path=['add', '<%- sortedAssociations[aindex].relationName _%>'];
          newError.extensions = {graphqlResponse:{data:response.data.data, errors:response.data.errors}};
          errorsD.current.push(newError);
          console.log("Error: ", newError);

          showMessageD(newError.message, withDetails);
          return;
        }
        
        //check: <%- queryName6 %> type
        if(!Number.isInteger(<%- queryName6 %>)) {
          let newError = {};
          let withDetails=true;
          variantD.current='error';
          newError.message = '<%- queryName6 %> ' + t('modelPanels.errors.data.e4', ' received, does not have the expected format.');
          newError.locations=[{model: '<%- name -%>', association: '<%- sortedAssociations[aindex].relationName _%>', table:'B', query: '<%- queryName6 %>', method: '<%- methodName6 %>', request: '<%- requestName6 %>'}];
          newError.path=['add', '<%- sortedAssociations[aindex].relationName _%>'];
          newError.extensions = {graphqlResponse:{data:response.data.data, errors:response.data.errors}};
          errorsD.current.push(newError);
          console.log("Error: ", newError);

          showMessageD(newError.message, withDetails);
          return;
        }

        //ok
        setCountB(<%- queryName6 %>);
<%if(sortedAssociations[aindex].paginationType === 'limitOffset') {-%>
        setIsCountingB(false);
<%}-%>
        isCountingRefB.current = false;

        //check: graphql errors
        if(response.data.errors) {
          let newError = {};
          let withDetails=true;
          variantD.current='info';
          newError.message = '<%- queryName6 %> ' + t('modelPanels.errors.data.e3', 'fetched with errors.');
          newError.locations=[{model: '<%- name -%>', association: '<%- sortedAssociations[aindex].relationName _%>', table:'B', query: '<%- queryName6 %>', method: '<%- methodName6 %>', request: '<%- requestName6 %>'}];
          newError.path=['add', '<%- sortedAssociations[aindex].relationName _%>'];
          newError.extensions = {graphQL:{data:response.data.data, errors:response.data.errors}};
          errorsD.current.push(newError);
          console.log("Error: ", newError);

          showMessageD(newError.message, withDetails);
        }
<%if(sortedAssociations[aindex].paginationType === 'limitOffset') {-%>

        /*
          Check: empty page
        */
        if( (<%- queryName6 %> === (pageRefB.current * rowsPerPageRefB.current)) && (pageRefB.current > 0) ) 
        {
          isOnApiRequestRefB.current = false;;
          setIsOnApiRequestB(false);
          setPageB(pageRefB.current-1);
          return;
        }

        /*
          Check: page overflow
        */
       if((pageRefB.current * rowsPerPageRefB.current) > <%- queryName6 %>) {
        isOnApiRequestRefB.current = false;
        setIsOnApiRequestB(false);
        setPageB(Math.floor(<%- queryName6 %> / rowsPerPageRefB.current));
        return;
      }
<%}-%>

      return;
    },
    //rejected
    (err) => {
      if(err.isCanceled) return;
      else throw err;
    })
    //error
    .catch((err) => { //error: on <%- requestName6 %>
      if(err.isCanceled) {
        return;
      } else {
        let newError = {};
        let withDetails=true;
        variantD.current='error';
        newError.message = t('modelPanels.errors.request.e1', 'Error in request made to server.');
        newError.locations=[{model: '<%- name -%>', association: '<%- sortedAssociations[aindex].relationName _%>', table:'B', query: '<%- queryName6 %>', method: '<%- methodName6 %>', request: '<%- requestName6 %>'}];
        newError.path=['add', '<%- sortedAssociations[aindex].relationName _%>'];
        newError.extensions = {error:{message:err.message, name:err.name, response:err.response}};
        errorsD.current.push(newError);
        console.log("Error: ", newError);

        showMessageD(newError.message, withDetails);
        return;
      }
    });
  }, [graphqlServerUrl, showMessageD, t, searchB]);
<%}-%>

<%
  /**
   * names
   */
  let methodName4 = 'getDataB()';
  let queryName4 = sortedAssociations[aindex].paginationType === 'limitOffset' ? sortedAssociations[aindex].targetModelPlLc : sortedAssociations[aindex].targetModelPlLc+'Connection';
  let requestName4 =  sortedAssociations[aindex].paginationType === 'limitOffset' ? 'api.'+sortedAssociations[aindex].targetModelLc+'.getItems' : 'api.'+sortedAssociations[aindex].targetModelLc+'.getItemsConnection';
-%>
  /**
   * getDataB
   * 
   * Get @items from GrahpQL Server.
   * Uses current state properties to fill query request.
   * Updates state to inform new @items retreived.
   * 
   */
  const getDataB = useCallback(() => {
    updateHeights();
    isOnApiRequestRefB.current = true;
    setIsOnApiRequestB(true);
    Boolean(dataTriggerB); //avoid warning
    errorsB.current = [];

<%_if( isToMany ){-%>
    //count (async)
    getCountB();
<%}-%>

    //set ops: only ids
    let ops = null;
    if(lidsToAdd.current && lidsToAdd.current.length > 0) {
      ops = {
        only: [{
          type: '<%- sortedAssociations[aindex].internalIdType _%>',
          values: {"<%- sortedAssociations[aindex].internalId _%>": lidsToAdd.current}
        }]
      };
    } else {
      clearRequestGetDataB();
      setThereAreItemsToAdd(false);
      return;
    }

<%if(sortedAssociations[aindex].paginationType === 'limitOffset') {-%>
    /*
      API Request: <%- queryName4 %>
    */
    let cancelableApiReqB = makeCancelable(api.<%- sortedAssociations[aindex].targetModelLc _%>.getItems(
      graphqlServerUrl,
      searchB,
      null, //orderBy
      null, //orderDirection
<%_if( isToMany ){-%>
      pageRefB.current * rowsPerPageRefB.current, //paginationOffset
      rowsPerPageRefB.current, //paginationLimit
<%} else {-%>
      0, //paginationOffset
      1, //paginationLimit
<%}-%>
      ops
    ));
<%} else if(sortedAssociations[aindex].paginationType === 'cursorBased') {-%>
    /*
      API Request: <%- queryName4 %>
    */
<%_if( isToMany ){-%>
    let variables = {
      pagination: {...paginationRefB.current}
    };
<%} else {-%>
    let variables = undefined;
<%}-%>
    let cancelableApiReqB = makeCancelable(api.<%- sortedAssociations[aindex].targetModelLc _%>.getItemsConnection(
      graphqlServerUrl,
      searchB,
      null, //orderBy
      null, //orderDirection
      variables,
      ops
    ));
<%}-%>
    cancelablePromises.current.push(cancelableApiReqB);
    cancelableApiReqB
      .promise
      .then(
      //resolved
      (response) => {
        //delete from cancelables
        cancelablePromises.current.splice(cancelablePromises.current.indexOf(cancelableApiReqB), 1);
        
        //check: response data
        if(!response.data ||!response.data.data) {
          let newError = {};
          let withDetails=true;
          variantB.current='error';
          newError.message = t('modelPanels.errors.data.e1', 'No data was received from the server.');
          newError.locations=[{model: '<%- name -%>', association: '<%- sortedAssociations[aindex].relationName _%>', table:'B', query: '<%- queryName4 %>', method: '<%- methodName4 %>', request: '<%- requestName4 %>'}];
          newError.path=['add', '<%- sortedAssociations[aindex].relationName _%>'];
          newError.extensions = {graphqlResponse:{data:response.data.data, errors:response.data.errors}};
          errorsB.current.push(newError);
          console.log("Error: ", newError);

          showMessageB(newError.message, withDetails);
          clearRequestGetDataB();
          return;
        }
        
        //check: <%- queryName4 %>
        let <%- queryName4 %> = response.data.data.<%- queryName4 %>;
        if(<%- queryName4 %> === null) {
          let newError = {};
          let withDetails=true;
          variantB.current='error';
          newError.message = '<%- queryName4 %> ' + t('modelPanels.errors.data.e2', 'could not be fetched.');
          newError.locations=[{model: '<%- name -%>', association: '<%- sortedAssociations[aindex].relationName _%>', table:'B', query: '<%- queryName4 %>', method: '<%- methodName4 %>', request: '<%- requestName4 %>'}];
          newError.path=['add', '<%- sortedAssociations[aindex].relationName _%>'];
          newError.extensions = {graphqlResponse:{data:response.data.data, errors:response.data.errors}};
          errorsB.current.push(newError);
          console.log("Error: ", newError);

          showMessageB(newError.message, withDetails);
          clearRequestGetDataB();
          return;
        }
        
<%if(sortedAssociations[aindex].paginationType === 'limitOffset') {-%>
        //check: <%- queryName4 %> type
        if(!Array.isArray(<%- queryName4 %>)) {
          let newError = {};
          let withDetails=true;
          variantB.current='error';
          newError.message = '<%- queryName4 %> ' + t('modelPanels.errors.data.e4', ' received, does not have the expected format.');
          newError.locations=[{model: '<%- name -%>', association: '<%- sortedAssociations[aindex].relationName _%>', table:'B', query: '<%- queryName4 %>', method: '<%- methodName4 %>', request: '<%- requestName4 %>'}];
          newError.path=['add', '<%- sortedAssociations[aindex].relationName _%>'];
          newError.extensions = {graphqlResponse:{data:response.data.data, errors:response.data.errors}};
          errorsB.current.push(newError);
          console.log("Error: ", newError);

          showMessageB(newError.message, withDetails);
          clearRequestGetDataB();
          return;
        }
        //get items
        let its = <%- queryName4 %>;

        //check: graphql errors
        if(response.data.errors) {
          let newError = {};
          let withDetails=true;
          variantB.current='info';
          newError.message = '<%- queryName4 %> ' + t('modelPanels.errors.data.e3', 'fetched with errors.');
          newError.locations=[{model: '<%- name -%>', association: '<%- sortedAssociations[aindex].relationName _%>', table:'B', query: '<%- queryName4 %>', method: '<%- methodName4 %>', request: '<%- requestName4 %>'}];
          newError.path=['add', '<%- sortedAssociations[aindex].relationName _%>'];
          newError.extensions = {graphQL:{data:response.data.data, errors:response.data.errors}};
          errorsB.current.push(newError);
          console.log("Error: ", newError);

          showMessageB(newError.message, withDetails);
        }

<%} else if(sortedAssociations[aindex].paginationType === 'cursorBased') {-%>
        //check: <%- queryName4 %> type
        if(typeof <%- queryName4 %> !== 'object'
        || !Array.isArray(<%- queryName4 %>.edges)
        || typeof <%- queryName4 %>.pageInfo !== 'object' 
        || <%- queryName4 %>.pageInfo === null) {
          let newError = {};
          let withDetails=true;
          variantB.current='error';
          newError.message = '<%- queryName4 %> ' + t('modelPanels.errors.data.e4', ' received, does not have the expected format.');
          newError.locations=[{model: '<%- name -%>', association: '<%- sortedAssociations[aindex].relationName _%>', table:'B', query: '<%- queryName4 %>', method: '<%- methodName4 %>', request: '<%- requestName4 %>'}];
          newError.path=['add', '<%- sortedAssociations[aindex].relationName _%>'];
          newError.extensions = {graphqlResponse:{data:response.data.data, errors:response.data.errors}};
          errorsB.current.push(newError);
          console.log("Error: ", newError);

          showMessageB(newError.message, withDetails);
          clearRequestGetDataB();
          return;
        }
        //get items
        let its = <%- queryName4 %>.edges.map(o => o.node);
<%_if( isToMany ){-%>
        let pi = <%- queryName4 %>.pageInfo;
<%}-%>

        //check: graphql errors
        if(response.data.errors) {
          let newError = {};
          let withDetails=true;
          variantB.current='info';
          newError.message = '<%- queryName4 %> ' + t('modelPanels.errors.data.e3', 'fetched with errors.');
          newError.locations=[{model: '<%- name -%>', association: '<%- sortedAssociations[aindex].relationName _%>', table:'B', query: '<%- queryName4 %>', method: '<%- methodName4 %>', request: '<%- requestName4 %>'}];
          newError.path=['add', '<%- sortedAssociations[aindex].relationName _%>'];
          newError.extensions = {graphQL:{data:response.data.data, errors:response.data.errors}};
          errorsB.current.push(newError);
          console.log("Error: ", newError);

          showMessageB(newError.message, withDetails);
        }

<%_if( isToMany ){-%>
        /*
          Check: empty page
        */
        if( its.length === 0 && pi.hasPreviousPage ) 
        {
          //configure
          isOnApiRequestRefB.current = false;
          isCursorPaginatingB.current = false;
          setIsOnApiRequestB(false);
          configurePaginationB('previousPage');
          
          //reload
          setDataTriggerB(prevDataTriggerB => !prevDataTriggerB);
          return;
        }//else

        //update pageInfo
        pageInfoB.current = pi;
        setHasPreviousPageB(pageInfoB.current.hasPreviousPage);
        setHasNextPageB(pageInfoB.current.hasNextPage);

        //configure pagination (default)
        configurePaginationB('reload');
<%}-%>
<%}-%>
          
        //ok
        setItemsB([...its]);

        //ends request
        isOnApiRequestRefB.current = false;
<%_if( isToMany ){-%>
<%if(sortedAssociations[aindex].paginationType === 'cursorBased') {-%>
        isCursorPaginatingB.current = false;
<%}-%>
<%}-%>
        setIsOnApiRequestB(false);
        return;

      },
      //rejected
      (err) => {
        if(err.isCanceled) return;
        else throw err;
      })
      //error
      .catch((err) => { //error: on <%- requestName4 %>
        if(err.isCanceled) {
          return;
        } else {
          let newError = {};
          let withDetails=true;
          variantB.current='error';
          newError.message = t('modelPanels.errors.request.e1', 'Error in request made to server.');
          newError.locations=[{model: '<%- name -%>', association: '<%- sortedAssociations[aindex].relationName _%>', table:'B', query: '<%- queryName4 %>', method: '<%- methodName4 %>', request: '<%- requestName4 %>'}];
          newError.path=['add', '<%- sortedAssociations[aindex].relationName _%>'];
          newError.extensions = {error:{message:err.message, name:err.name, response:err.response}};
          errorsB.current.push(newError);
          console.log("Error: ", newError);

          showMessageB(newError.message, withDetails);
          clearRequestGetDataB();
          return;
        }
      });
  }, [graphqlServerUrl, showMessageB, clearRequestGetDataB, t, dataTriggerB, searchB<%if( isToMany ) {-%>, getCountB<%}-%><%if(sortedAssociations[aindex].paginationType === 'cursorBased' && isToMany) {-%>, configurePaginationB<%}-%>]);

  /**
   * Effects
   */
  useEffect(() => {

    //cleanup on unmounted.
    return function cleanup() {
      cancelablePromises.current.forEach(p => p.cancel());
      cancelablePromises.current = [];
      cancelableCountingPromises.current.forEach(p => p.cancel());
      cancelableCountingPromises.current = [];
<%_if( isToMany ){-%>
      cancelableCountingPromisesB.current.forEach(p => p.cancel());
      cancelableCountingPromisesB.current = [];
<%}-%>
    };
  }, []);

  useEffect(() => {
    if (!isOnApiRequestRef.current) {
      getData();
    } 
    else { 
      isPendingApiRequestRef.current = true; 
    }
  }, [getData]);

  useEffect(() => {
    if (!isOnApiRequestRefB.current) {
      getDataB();
    } 
    else { 
      isPendingApiRequestRefB.current = true; 
    }
  }, [getDataB]);

  useEffect(() => {
    /*
     * Handle changes 
     */
    
    /*
     * Checks
     */
    if(!lastModelChanged) {
      return;
    }
    if(!lastChangeTimestamp || !lastFetchTime.current || !lastFetchTimeB.current) {
      return;
    }
    let isNewChangeOnA = (lastFetchTime.current<lastChangeTimestamp);
    let isNewChangeOnB = (lastFetchTimeB.current<lastChangeTimestamp);
    if(!isNewChangeOnA && !isNewChangeOnB) {
      return;
    }

    /*
     * Update timestamps
     */
    lastFetchTime.current = Date.now();
    lastFetchTimeB.current = Date.now();

    /*
     * Case 1: 
     * The attributes of some '<%- sortedAssociations[aindex].targetModel _%>' were modified or the item was deleted.
     * 
     * Conditions:
     * A: the item was modified and is currently displayed in any of the lists.
     * B: the item was deleted and is currently displayed in any of the lists.
     * 
     * Actions:
     * if A:
     * - update the list with the new item.
     * - return
     * 
     * if B:
     * - remove the deleted internalId from idsToAdd[]
     * - reload both transfer tables.
     * - return
     */
    if(lastModelChanged.<%- sortedAssociations[aindex].targetModel _%>) {

      let oens = Object.entries(lastModelChanged.<%- sortedAssociations[aindex].targetModel _%>);
      oens.forEach( (entry) => {
<%#
/**
 * Special case: user model
 */
-%>
<% if(sortedAssociations[aindex].targetModelLc==='user') {%>
        //case A: updated || updated password
        if((entry[1].op === "update" || entry[1].op === "updatePassword")&&entry[1].newItem) {
<%} else {-%>
        //case A: updated
        if(entry[1].op === "update"&&entry[1].newItem) {
<%}-%>
          let idUpdated = entry[1].item.<%- sortedAssociations[aindex].internalId _%>;
          
          //lookup item on table A
          let nitemsA = Array.from(items);
          let iofA = nitemsA.findIndex((item) => item.<%- sortedAssociations[aindex].internalId _%>===idUpdated);
          if(iofA !== -1) {
            //set new item
            nitemsA[iofA] = entry[1].newItem;
            setItems(nitemsA);
          }

          //lookup item on table B
          let nitemsB = Array.from(itemsB);
          let iofB = nitemsB.findIndex((item) => item.<%- sortedAssociations[aindex].internalId _%>===idUpdated);
          if(iofB !== -1) {
            //set new item
            nitemsB[iofB] = entry[1].newItem;
            setItemsB(nitemsB);
          }
        }

        //case B: deleted
        if(entry[1].op === "delete") {
          let idRemoved = entry[1].item.<%- sortedAssociations[aindex].internalId _%>;

          //lookup item on table A
          let iofA = items.findIndex((item) => item.<%- sortedAssociations[aindex].internalId _%>===idRemoved);
          if(iofA !== -1) {
            //decrement A
            setCount(count-1);
          }

<%_if( isToMany ){-%>
          //lookup item on table B
          let iofB = itemsB.findIndex((item) => item.<%- sortedAssociations[aindex].internalId _%>===idRemoved);
          if(iofB !== -1) {
            //decrement B
            setCountB(countB-1);
          }
<%}-%>

          //lookup item on ids to add
          let iofD = lidsToAdd.current.indexOf(idRemoved);
          //remove deleted item from lidsToAdd
          if(iofD !== -1) {
            lidsToAdd.current.splice(iofD, 1);
            if(lidsToAdd.current.length === 0) {
              setThereAreItemsToAdd(false);
            }
<%_if( isToMany ){-%>
            if(iofB === -1) {
              //decrement B
              setCountB(countB-1);
            }
<%}-%>
          }
          handleUntransfer('<%- sortedAssociations[aindex].relationName _%>', idRemoved);

          //will count A
          cancelCountingPromises();
          isCountingRef.current = false;
<%_if( isToMany ){-%>
          //will count B
          cancelCountingPromisesB();
          isCountingRefB.current = false;
<%}-%>

<%if(sortedAssociations[aindex].paginationType === 'limitOffset') {-%>
            //reload A
            if (!isOnApiRequestRef.current) { setDataTrigger(prevDataTrigger => !prevDataTrigger); }
            else { isPendingApiRequestRef.current = true; getCount(); }
            //reload B
            if (!isOnApiRequestRefB.current) { setDataTriggerB(prevDataTriggerB => !prevDataTriggerB); }
<%_if( isToMany ){-%>
            else { isPendingApiRequestRefB.current = true; getCountB(); }
<%} else {-%>
            else { isPendingApiRequestRefB.current = true; }
<%}-%> 
<%} else if(sortedAssociations[aindex].paginationType === 'cursorBased') {-%>
          //strict contention
          if (!isOnApiRequestRef.current && !isCursorPaginating.current) {
            //configure A
            configurePagination('reload');
            //reload A
            setDataTrigger(prevDataTrigger => !prevDataTrigger);
          } else {
            getCount();
          }
          //strict contention
<%_if( isToMany ){-%>
          if (!isOnApiRequestRefB.current && !isCursorPaginatingB.current) {
            //configure B
            configurePaginationB('reload');
            //reload B
            setDataTriggerB(prevDataTriggerB => !prevDataTriggerB);
          } else {
            getCountB();
          }
<%} else {-%>
          if (!isOnApiRequestRefB.current) {
            //reload B
            setDataTriggerB(prevDataTriggerB => !prevDataTriggerB);
          }
<%}-%>
<%}-%>
          return;
        }
      });
    }//end: Case 1
  }, [lastModelChanged, lastChangeTimestamp, items, itemsB, handleUntransfer, getCount, count<%_if( isToMany ){-%>, getCountB, countB<%}-%><%if(sortedAssociations[aindex].paginationType === 'cursorBased') {-%>, configurePagination<%}-%><%if(sortedAssociations[aindex].paginationType === 'cursorBased' && isToMany) {-%>, configurePaginationB<%}-%>]);
  
  useEffect(() => {
    //return if this flag is set
    if(isGettingFirstDataRef.current) { 
      isGettingFirstDataRef.current = false; 
      return; 
    } 
    else {
      //get data from the new page
      pageRef.current = page;
      if (!isOnApiRequestRef.current) {
        setDataTrigger(prevDataTrigger => !prevDataTrigger); 
      } 
      else { 
        isPendingApiRequestRef.current = true; 
      }
    }
  }, [page]);

  useEffect(() => {
    //return on first render
    if(isGettingFirstDataRefB.current) { 
      isGettingFirstDataRefB.current = false; 
      return; 
    } 
    else {
      //get data from the new page
      pageRefB.current = pageB;
      if (!isOnApiRequestRefB.current) {
        setDataTriggerB(prevDataTriggerB => !prevDataTriggerB); 
      } 
      else { 
        isPendingApiRequestRefB.current = true; 
      }
    }
  }, [pageB]);

<%if(sortedAssociations[aindex].paginationType === 'limitOffset') {-%>
  useEffect(() => {
    //update ref
    rowsPerPageRef.current = rowsPerPage;
    
    //reload
    if (!isOnApiRequestRef.current) { setDataTrigger(prevDataTrigger => !prevDataTrigger); } 
    else { isPendingApiRequestRef.current = true; }
  }, [rowsPerPage]);
<%} else if(sortedAssociations[aindex].paginationType === 'cursorBased') {-%>
  useEffect(() => {
    //update ref
    rowsPerPageRef.current = rowsPerPage;

    //check strict contention
    if(isOnApiRequestRef.current || isCursorPaginating.current) { return; }
    //set strict contention
    isCursorPaginating.current = true;
    
    //configure pagination
    configurePagination('reset');
    //reload    
    setDataTrigger(prevDataTrigger => !prevDataTrigger);
  }, [rowsPerPage, configurePagination]);
<%}-%>

<%_if( isToMany ){-%>
<%if(sortedAssociations[aindex].paginationType === 'limitOffset') {-%>
  useEffect(() => {
    //update ref
    rowsPerPageRefB.current = rowsPerPageB;
    
    //reload
    if (!isOnApiRequestRefB.current) { setDataTriggerB(prevDataTrigger => !prevDataTrigger); } 
    else { isPendingApiRequestRefB.current = true; }
  }, [rowsPerPageB]);
<%} else if(sortedAssociations[aindex].paginationType === 'cursorBased') {-%>
  useEffect(() => {
    //update ref
    rowsPerPageRefB.current = rowsPerPageB;

    //check strict contention
    if(isOnApiRequestRefB.current || isCursorPaginatingB.current) { return; }
    //set strict contention
    isCursorPaginatingB.current = true;
    
    //configure pagination
    configurePaginationB('reset');
    //reload    
    setDataTriggerB(prevDataTrigger => !prevDataTrigger);
  }, [rowsPerPageB, configurePaginationB]);
<%}-%>
<%}-%>

  useEffect(() => {
    if (!isOnApiRequest && isPendingApiRequestRef.current) {
      isPendingApiRequestRef.current = false;
<%if(sortedAssociations[aindex].paginationType === 'limitOffset') {-%>
      //reload
      setDataTrigger(prevDataTrigger => !prevDataTrigger);
<%} else if(sortedAssociations[aindex].paginationType === 'cursorBased') {-%>
      //configure
      configurePagination('reload');
      //reload
      setDataTrigger(prevDataTrigger => !prevDataTrigger);
<%}-%>
    }
    updateHeights();
  }, [isOnApiRequest<%if(sortedAssociations[aindex].paginationType === 'cursorBased') {-%>, configurePagination<%}-%>]);

  useEffect(() => {
    if (!isOnApiRequestB && isPendingApiRequestRefB.current) {
      isPendingApiRequestRefB.current = false;
<%if(sortedAssociations[aindex].paginationType === 'limitOffset') {-%>
      //reload
      setDataTriggerB(prevDataTriggerB => !prevDataTriggerB);
<%} else if(sortedAssociations[aindex].paginationType === 'cursorBased') {-%>
<%_if( isToMany ){-%>
      //configure
      configurePaginationB('reload');
<%}-%>
      //reload
      setDataTriggerB(prevDataTriggerB => !prevDataTriggerB);
<%}-%>
    }
    updateHeights();
  }, [isOnApiRequestB<%if(sortedAssociations[aindex].paginationType === 'cursorBased' && isToMany) {-%>, configurePaginationB<%}-%>]);

  useEffect(() => {
    if(Array.isArray(items) && items.length > 0) { 
      setAreItemsReady(true); 
    } else { 
      setAreItemsReady(false); 
    }
    lastFetchTime.current = Date.now();
  }, [items]);

  useEffect(() => {
    if(Array.isArray(itemsB) && itemsB.length > 0) { 
      setAreItemsReadyB(true); 
    } else { 
      setAreItemsReadyB(false); 
    }
    lastFetchTimeB.current = Date.now();
  }, [itemsB]);

  /**
   * Utils
   */
  function cancelCountingPromises() {
    cancelableCountingPromises.current.forEach(p => p.cancel());
    cancelableCountingPromises.current = [];    
  }
<%_if( isToMany ){-%>
  function cancelCountingPromisesB() {
    cancelableCountingPromisesB.current.forEach(p => p.cancel());
    cancelableCountingPromisesB.current = [];    
  }
<%}-%>

  function updateHeights() {
    if(lref.current) {
      let h =lref.current.clientHeight;
      setLh(h);
    }
    if(lrefB.current) {
      let hb =lrefB.current.clientHeight;
      setLhB(hb);
    }
  }

<%if(sortedAssociations[aindex].paginationType === 'limitOffset') {-%>
  function resetPageRefs() {
    pageRef.current = 0;
  }

  function resetPageRefsB() {
    pageRefB.current = 0;
  }

  function resetReloadDataA() {
    //reload A
    resetPageRefs();
    if (!isOnApiRequestRef.current) { setDataTrigger(prevDataTrigger => !prevDataTrigger); } 
    else { isPendingApiRequestRef.current = true; }
  }

  function resetReloadDataB() {
    //reload B
    resetPageRefsB();
    if (!isOnApiRequestRefB.current) { setDataTriggerB(prevDataTriggerB => !prevDataTriggerB); } 
    else { isPendingApiRequestRefB.current = true; }
  }
<%}-%>

  function reloadDataA() {
<%if(sortedAssociations[aindex].paginationType === 'limitOffset') {-%>
    //reload A
    setDataTrigger(prevDataTrigger => !prevDataTrigger); 
<%} else if(sortedAssociations[aindex].paginationType === 'cursorBased') {-%>
    //configure A
    configurePagination('reload');
    //reload A
    setDataTrigger(prevDataTrigger => !prevDataTrigger);
<%}-%>
  }

  function reloadDataB() {
<%if(sortedAssociations[aindex].paginationType === 'limitOffset') {-%>
    //reload B
    setDataTriggerB(prevDataTriggerB => !prevDataTriggerB);
<%} else if(sortedAssociations[aindex].paginationType === 'cursorBased') {-%>
<%_if( isToMany ){-%>
    //configure B
    configurePaginationB('reload');    
<%}-%>
    //reload B
    setDataTriggerB(prevDataTriggerB => !prevDataTriggerB);
<%}-%>
  }

  /**
   * Handlers
   */

  /*
   * Search handlers
   */
  const handleSearchEnter = text => {
    if(text !== search)
    {
<%if(sortedAssociations[aindex].paginationType === 'limitOffset') {-%>
      resetPageRefs();
<%}-%>
      if(page !== 0) {
        isGettingFirstDataRef.current = true; //avoids to get data on [page] effect
        setPage(0);
      }
      
      setCount(-1);
      //will count
      cancelCountingPromises();
      isCountingRef.current = false;

      setSearch(text);
    }
  };

  const handleSearchEnterB = text => {
    if(text !== searchB)
    {
<%if(sortedAssociations[aindex].paginationType === 'limitOffset') {-%>
      resetPageRefsB();
<%}-%>
      if(pageB !== 0) {
        isGettingFirstDataRefB.current = true; //avoids to get data on [pageB] effect
        setPageB(0);
      }
<%_if( isToMany ){-%>
      setCountB(-1);
      //will count
      cancelCountingPromisesB();
      isCountingRefB.current = false;
<%}-%>

      setSearchB(text);
    }
  };

  /*
   * Pagination handlers
   */
<%if(sortedAssociations[aindex].paginationType === 'limitOffset') {-%>
  const handleChangePage = (event, newPage) => {
    setPage(newPage);
  };

<%_if( isToMany ){-%>
  const handleChangePageB = (event, newPage) => {
    setPageB(newPage);
  };
<%}-%>
<%}-%>

<%if(sortedAssociations[aindex].paginationType === 'cursorBased') {-%>
  const handleFirstPageButtonClick = (event) => {
    //strict contention
    if (isOnApiRequestRef.current || isCursorPaginating.current) { return; }
    //set strict contention
    isCursorPaginating.current = true;
    //configure A
    configurePagination('firstPage');
    //reload A
    setDataTrigger(prevDataTrigger => !prevDataTrigger);
  };

<%_if( isToMany ){-%>
  const handleFirstPageButtonClickB = (event) => {
    //strict contention
    if (isOnApiRequestRefB.current || isCursorPaginatingB.current) { return; }
    //set strict contention
    isCursorPaginatingB.current = true;
    //configure B
    configurePaginationB('firstPage');
    //reload B
    setDataTriggerB(prevDataTriggerB => !prevDataTriggerB);
  };
<%}-%>

  const handleLastPageButtonClick = (event) => {
    //strict contention
    if (isOnApiRequestRef.current || isCursorPaginating.current) { return; }
    //set strict contention
    isCursorPaginating.current = true;
    //configure A
    configurePagination('lastPage');
    //reload A
    setDataTrigger(prevDataTrigger => !prevDataTrigger);
  };

<%_if( isToMany ){-%>
  const handleLastPageButtonClickB = (event) => {
    //strict contention
    if (isOnApiRequestRefB.current || isCursorPaginatingB.current) { return; }
    //set strict contention
    isCursorPaginatingB.current = true;
    //configure B
    configurePaginationB('lastPage');
    //reload B
    setDataTriggerB(prevDataTriggerB => !prevDataTriggerB);
  };
<%}-%>

  const handleNextButtonClick = (event) => {
    //strict contention
    if (isOnApiRequestRef.current || isCursorPaginating.current) { return; }
    //set strict contention
    isCursorPaginating.current = true;
    //configure A
    configurePagination('nextPage');
    //reload A
    setDataTrigger(prevDataTrigger => !prevDataTrigger);
  };

<%_if( isToMany ){-%>
  const handleNextButtonClickB = (event) => {
    //strict contention
    if (isOnApiRequestRefB.current || isCursorPaginatingB.current) { return; }
    //set strict contention
    isCursorPaginatingB.current = true;
    //configure B
    configurePaginationB('nextPage');
    //reload B
    setDataTriggerB(prevDataTriggerB => !prevDataTriggerB);
  };
<%}-%>

  const handleBackButtonClick = (event) => {
    //strict contention
    if (isOnApiRequestRef.current || isCursorPaginating.current) { return; }
    //set strict contention
    isCursorPaginating.current = true;
    //configure A
    configurePagination('previousPage');
    //reload A
    setDataTrigger(prevDataTrigger => !prevDataTrigger);
  };

<%_if( isToMany ){-%>
  const handleBackButtonClickB = (event) => {
    //strict contention
    if (isOnApiRequestRefB.current || isCursorPaginatingB.current) { return; }
    //set strict contention
    isCursorPaginatingB.current = true;
    //configure B
    configurePaginationB('previousPage');

    //reload B
    setDataTriggerB(prevDataTriggerB => !prevDataTriggerB);
  };
<%}-%>
<%}-%>

  const handleChangeRowsPerPage = event => {
    if(event.target.value !== rowsPerPage)
    {
<%if(sortedAssociations[aindex].paginationType === 'limitOffset') {-%>
      resetPageRefs();
<%}-%>
      if(page !== 0) {
        isGettingFirstDataRef.current = true; //avoids to get data on [page] effect
        setPage(0);
      }

      setRowsPerPage(parseInt(event.target.value, 10));
    }
  };

<%_if( isToMany ){-%>
  const handleChangeRowsPerPageB = event => {
    if(event.target.value !== rowsPerPageB)
    {
<%if(sortedAssociations[aindex].paginationType === 'limitOffset') {-%>
      resetPageRefsB();
<%}-%>
      if(pageB !== 0) {
        isGettingFirstDataRefB.current = true; //avoids to get data on [pageB] effect
        setPageB(0);
      }
      setRowsPerPageB(parseInt(event.target.value, 10));
    }
  };
<%}-%>

<%if(sortedAssociations[aindex].paginationType === 'limitOffset') {-%>
  const handleReloadClick = (event) => {
    resetReloadDataA();
  };
  const handleReloadClickB = (event) => {
    resetReloadDataB();
  };
<%} else if(sortedAssociations[aindex].paginationType === 'cursorBased') {-%>
  const handleReloadClick = (event) => {
    //check strict contention
    if(isOnApiRequestRef.current || isCursorPaginating.current) { return; }
    //set strict contention
    isCursorPaginating.current = true;
    //configure pagination
    configurePagination('reset');
    //reload
    setDataTrigger(prevDataTrigger => !prevDataTrigger);
  };
  const handleReloadClickB = (event) => {
<%_if( isToMany ){-%>
    //check strict contention
    if(isOnApiRequestRefB.current || isCursorPaginatingB.current) { return; }
    //set strict contention
    isCursorPaginatingB.current = true;
    //configure pagination
    configurePaginationB('reset');
    //reload
    setDataTriggerB(prevDataTriggerB => !prevDataTriggerB);
<%} else {-%>
    //check strict contention
    if(isOnApiRequestRefB.current) { return; }
    //reload
    setDataTriggerB(prevDataTriggerB => !prevDataTriggerB);
<%}-%>
  };
<%}-%>
  
  /*
   * Items handlers
   */
  const handleRowClicked = (event, item) => {
    handleClickOn<%- sortedAssociations[aindex].targetModelCp _%>Row(event, item);
  };

  const handleAddItem = (event, item) => {
<%_if( isToMany ){-%>
    if(lidsToAdd.current.indexOf(item.<%- sortedAssociations[aindex].internalId _%>) === -1) {
      lidsToAdd.current.push(item.<%- sortedAssociations[aindex].internalId _%>);
      setThereAreItemsToAdd(true);
      
      //decrement count A
      setCount(count-1);
      //will count A
      cancelCountingPromises();
      isCountingRef.current = false;
      //reload A
      reloadDataA();

      //increment count B
      if(countB > 0) setCountB(countB+1);
      //will count B
      cancelCountingPromisesB();
      isCountingRefB.current = false;
<%if(sortedAssociations[aindex].paginationType === 'limitOffset') {-%>
      //reset B
      resetReloadDataB();
<%} else if(sortedAssociations[aindex].paginationType === 'cursorBased') {-%>
      //configure B
      configurePaginationB('reset');
      //reload B
      setDataTriggerB(prevDataTriggerB => !prevDataTriggerB);
<%}-%>
      handleTransfer('<%- sortedAssociations[aindex].relationName _%>', item.<%- sortedAssociations[aindex].internalId _%>);
    }
<%} else {-%>
    if(lidsToAdd.current.indexOf(item.<%- sortedAssociations[aindex].internalId _%>) === -1) {
      let hasItem = (lidsToAdd.current&&lidsToAdd.current.length > 0);
      lidsToAdd.current = [];
      lidsToAdd.current.push(item.<%- sortedAssociations[aindex].internalId _%>);
      setThereAreItemsToAdd(true);

      if(!hasItem) {
        //decrement count A
        setCount(count-1);
        //will count A
        cancelCountingPromises();
        isCountingRef.current = false;
      }
      //reload A
      reloadDataA();
<%if(sortedAssociations[aindex].paginationType === 'limitOffset') {-%>
      //reset B
      resetReloadDataB();
<%} else if(sortedAssociations[aindex].paginationType === 'cursorBased') {-%>
      //reload B
      setDataTriggerB(prevDataTriggerB => !prevDataTriggerB);
<%}-%>
      handleTransfer('<%- sortedAssociations[aindex].relationName _%>', item.<%- sortedAssociations[aindex].internalId _%>);
    }
<%}-%>
  };

  const handleRemoveItem = (event, item) => {
<%_if( isToMany ){-%>
    let iof = lidsToAdd.current.indexOf(item.<%- sortedAssociations[aindex].internalId _%>);
    if(iof !== -1) { 
      lidsToAdd.current.splice(iof, 1);

      if(lidsToAdd.current.length === 0) {
        setThereAreItemsToAdd(false);
      }

      //increment count A
      setCount(count+1);
      //will count A
      cancelCountingPromises();
      isCountingRef.current = false;
<%if(sortedAssociations[aindex].paginationType === 'limitOffset') {-%>
      //reset A
      resetReloadDataA();
<%} else if(sortedAssociations[aindex].paginationType === 'cursorBased') {-%>
      //configure A
      configurePaginationB('reset');
      //reload A
      setDataTrigger(prevDataTrigger => !prevDataTrigger);
<%}-%>

      //decrement count B
      if(countB > 0) setCountB(countB-1);
      //will count B
      cancelCountingPromisesB();
      isCountingRefB.current = false;
      //reload B
      reloadDataB();
      handleUntransfer('<%- sortedAssociations[aindex].relationName _%>', item.<%- sortedAssociations[aindex].internalId _%>);
    }
<%} else {-%>
    if(lidsToAdd.current.length > 0) {
      let hasItem = (lidsToAdd.current&&lidsToAdd.current.length > 0);
      lidsToAdd.current = [];
      setThereAreItemsToAdd(false);

      if(hasItem) {
        //increment count A
        setCount(count+1);
        //will count A
        cancelCountingPromises();
        isCountingRef.current = false;
      }
<%if(sortedAssociations[aindex].paginationType === 'limitOffset') {-%>
      //reset A
      resetReloadDataA();
<%} else if(sortedAssociations[aindex].paginationType === 'cursorBased') {-%>
      //reload A
      setDataTrigger(prevDataTrigger => !prevDataTrigger);
<%}-%>
      //reload B
      reloadDataB();
      handleUntransfer('<%- sortedAssociations[aindex].relationName _%>', item.<%- sortedAssociations[aindex].internalId _%>);
    }
<%}-%>
  };

  return (
    <div className={classes.root}>
      <Grid className={classes.container} container spacing={0} alignItems='flex-start' justify='center'>
        {/*
          * Selectable list (A)
          */}
        <Grid item xs={12} sm={5} >
          <Card className={classes.card}>

            {/* Toolbar */}
            <<%- sortedAssociations[aindex].relationNameOnPascal _%>ToAddTransferViewToolbar 
              title={'<%- sortedAssociations[aindex].targetModelPlCp _%>'}
              titleIcon={1}
              search={search}
              onSearchEnter={handleSearchEnter}
              onReloadClick={handleReloadClick}
            />

            {/* Case: no data */}
            {(!isOnApiRequest && (!areItemsReady)) && (
              /* Label */
              <Fade
                in={true}
                unmountOnExit
              >
                <div id='<%- sortedAssociations[aindex].relationNameOnPascal -%>ToAddTransferView-div-noDataA'>
                  <Grid container>
                    <Grid item xs={12}>
                      <Grid className={classes.noDataBox} container justify="center" alignItems="center">
                        <Grid item>
                          <Typography variant="body2" >{ t('modelPanels.noData') }</Typography>
                        </Grid>
                      </Grid>
                    </Grid>
                  </Grid>
                </div>
              </Fade>
            )}

            {/* Case: data ready */}
            {(!isOnApiRequest && areItemsReady) && (
            
              /* List */
              <Fade
                in={true}
                unmountOnExit
              >
                <Box className={classes.listBox} ref={lref}>
                  <List id='<%- sortedAssociations[aindex].relationNameOnPascal -%>ToAddTransferView-list-listA'
                  dense component="div" role="list" >
                    {items.map(it => {
                      let key = it.<%- sortedAssociations[aindex].internalId _%>;
                      let label = <%- (sortedAssociations[aindex].label!==undefined && sortedAssociations[aindex].label!=='' && sortedAssociations[aindex].label !==  sortedAssociations[aindex].internalId) ? `it.${sortedAssociations[aindex].label}` : 'undefined' _%>;
                      let sublabel = <%- (sortedAssociations[aindex].sublabel!==undefined && sortedAssociations[aindex].sublabel!=='' && sortedAssociations[aindex].sublabel !==  sortedAssociations[aindex].label && sortedAssociations[aindex].sublabel !==  sortedAssociations[aindex].internalId) ? `it.${sortedAssociations[aindex].sublabel}` : 'undefined' _%>;

                      return (
                        <ListItem 
                          id={'<%- sortedAssociations[aindex].relationNameOnPascal -%>ToAddTransferView-listA-listItem-'+it.<%- sortedAssociations[aindex].internalId _%>}
                          key={key} 
                          role="listitem" 
                          button 
                          className={classes.row}
                          onClick={(event) => {
                            handleRowClicked(event, it);
                          }}
                        >
                          <ListItemAvatar>
                            <Tooltip title={ '<%- sortedAssociations[aindex].targetModel %>' }>
                              <Avatar>{"<%- sortedAssociations[aindex].targetModelLc%>".slice(0,1)}</Avatar>
                            </Tooltip>
                          </ListItemAvatar>

                          <ListItemText
                            primary={
                              <React.Fragment>
                                {/* <%- internalId _%> */}
                                <Grid container alignItems='center' alignContent='center' wrap='nowrap' spacing={1}>
                                  <Grid item>
                                    <Tooltip title={ '<%- sortedAssociations[aindex].internalId %>' }>
                                      <Typography variant="body1" display="block" noWrap={true}>{it.<%- sortedAssociations[aindex].internalId _%>}</Typography>
                                    </Tooltip>
                                  </Grid>
                                  {/*Key icon*/}
                                  <Grid item>
                                    <Tooltip title={ t('modelPanels.internalId', 'Unique Identifier') }>
                                      <Key fontSize="small" color="disabled" style={{ marginTop:8}} />
                                    </Tooltip>
                                  </Grid>
                                </Grid>
                              </React.Fragment>
                            }
                            secondary={
                              <React.Fragment>
                                {/* Label */}
                                {(label) && (
                                  <Tooltip title={ '<%- sortedAssociations[aindex].label %>' }>
                                    <Typography component="span" variant="body1" display="inline" color="textPrimary">{label}</Typography>
                                  </Tooltip>
                                )}
                                
                                {/* Sublabel */}
                                {(sublabel) && (
                                  <Tooltip title={ '<%- sortedAssociations[aindex].sublabel %>' }>
                                    <Typography component="span" variant="body2" display="inline" color='textSecondary'>{" — "+sublabel} </Typography>
                                  </Tooltip>
                                )}
                              </React.Fragment>
                            }
                          />
                          {/* Button: Add */}
                          <ListItemSecondaryAction>
                            <Tooltip title={ t('modelPanels.transferToAdd') }>
                              <IconButton
                                id={'<%- sortedAssociations[aindex].relationNameOnPascal -%>ToAddTransferView-listA-listItem-'+it.<%- sortedAssociations[aindex].internalId _%>+'-button-add'}
                                color="primary"
                                className={classes.iconButton}
                                onClick={(event) => {
                                  event.stopPropagation();
                                  handleAddItem(event, it);
                                }}
                              >
                                <Add htmlColor="#4CAF50" />
                              </IconButton>
                            </Tooltip>
                          </ListItemSecondaryAction>
                        </ListItem>
                      );
                    })}
                  </List>
                </Box>
              </Fade>
            )}
            {/* Case: loading */}
            {(isOnApiRequest) && (
              /* Progress */
              <Fade
                in={true}
                unmountOnExit
              >
                <div>
                  <Grid container>
                    <Grid item xs={12}>
                      <Box height={lh}>
                        <Grid container className={classes.loadingBox} justify="center" alignItems="center">
                          <Grid item>
                            <CircularProgress color='primary' disableShrink />
                          </Grid>
                        </Grid>
                      </Box>
                    </Grid>
                  </Grid>
                </div>
              </Fade>
            )}

            {/* Pagination */}
<%if(sortedAssociations[aindex].paginationType === 'limitOffset') {-%>
            <TablePagination
              rowsPerPageOptions={(count <=10) ? [] : (count <=50) ? [5, 10, 25, 50] : [5, 10, 25, 50, 100]}
              component="div"
              count={count}
              rowsPerPage={rowsPerPage}
              page={page}
              labelRowsPerPage = { t('modelPanels.rows', 'Rows') }
              labelDisplayedRows = {({ from, to }) => `${(count<0) ? '': from}${(count<0) ? '': '-'}${(count<0) ? '': to} ${(count<0) ? '': (isCounting) ? '' : t('modelPanels.of')} ${(count<0) ? '?': (isCounting) ? '' : count}`}
              onChangePage={handleChangePage}
              onChangeRowsPerPage={handleChangeRowsPerPage}
            />
<%} else if(sortedAssociations[aindex].paginationType === 'cursorBased') {-%>
            <<%- sortedAssociations[aindex].relationNameOnPascal _%>ToAddTransferViewCursorPagination
              count={count}
              rowsPerPageOptions={(count <=10) ? [] : (count <=50) ? [5, 10, 25, 50] : [5, 10, 25, 50, 100]}
              rowsPerPage={(count <=10) ? '' : rowsPerPage}
              labelRowsPerPage = { t('modelPanels.rows', 'Rows') }
              hasNextPage={hasNextPage}
              hasPreviousPage={hasPreviousPage}
              handleFirstPageButtonClick={handleFirstPageButtonClick}
              handleLastPageButtonClick={handleLastPageButtonClick}
              handleNextButtonClick={handleNextButtonClick}
              handleBackButtonClick={handleBackButtonClick}
              handleChangeRowsPerPage={handleChangeRowsPerPage}
            />
<%}-%>
          </Card>
        </Grid>
        {/*
          * Arrows
          */}
        <Hidden xsDown>
          <Grid item xs={1} >
            <Grid container className={classes.arrowsBox} justify='center'>
              <TransferArrows
                color="primary"
                fontSize="large"
                component={svgProps => {
                  return (
                    <svg {...svgProps}>
                      <defs>
                        <linearGradient id="gradient3">
                          <stop offset="30%" stopColor={(itemsB&&itemsB.length>0) ? "#3F51B5" : blueGrey[200]} />
                          <stop offset="70%" stopColor={(items&&items.length>0) ? "#4CAF50" : blueGrey[200]} />
                        </linearGradient>
                      </defs>
                      {React.cloneElement(svgProps.children[0], {
                        fill: 'url(#gradient3)',
                      })}
                    </svg>
                  );
                }}
              />
            </Grid>
          </Grid>
        </Hidden>
        <Hidden smUp>
            <Grid item xs={1} >
              <Grid container className={classes.arrowsBox} justify='center'>
                <TransferArrows
                  className={classes.arrowsV}
                  color="primary"
                  fontSize="large"
                  component={svgProps => {
                    return (
                      <svg {...svgProps}>
                        <defs>
                          <linearGradient id="gradient3b">
                            <stop offset="30%" stopColor={(itemsB&&itemsB.length>0) ? "#3F51B5" : blueGrey[200]} />
                            <stop offset="70%" stopColor={(items&&items.length>0) ? "#4CAF50" : blueGrey[200]} />
                          </linearGradient>
                        </defs>
                        {React.cloneElement(svgProps.children[0], {
                          fill: 'url(#gradient3b)',
                        })}
                      </svg>
                    );
                  }}
                />
              </Grid>
            </Grid>
          </Hidden>

        {/*
          * To add list (B) 
          */}
        <Grid item xs={12} sm={5} >
          <Card className={classes.card}>

            {/* Toolbar */}
            <<%- sortedAssociations[aindex].relationNameOnPascal _%>ToAddTransferViewToolbar 
              title={'<%- (isToOne) ? sortedAssociations[aindex].targetModelCp : sortedAssociations[aindex].targetModelPlCp %>'}
              titleIcon={2}
              search={searchB}
<%if(isToOne) {-%>
              searchDisabled={true}
<%}-%>
              onSearchEnter={handleSearchEnterB}
              onReloadClick={handleReloadClickB}
            />

            {/* Case: no items added */}
            {(!thereAreItemsToAdd) && (
              /* Label */
              <Fade
                in={true}
                unmountOnExit
              >
                <div id='<%- sortedAssociations[aindex].relationNameOnPascal -%>ToAddTransferView-div-noItemsB'>
                  <Grid container>
                    <Grid item xs={12}>
                      <Grid className={classes.noDataBox} container justify="center" alignItems="center">
                        <Grid item>
                          <Typography variant="body2" >{ t('modelPanels.noItemsToAdd', 'No records marked for association') }</Typography>
                        </Grid>
                      </Grid>
                    </Grid>
                  </Grid>
                </div>
              </Fade>
            )}

            {/* Case: no data from search */}
            {(thereAreItemsToAdd && !isOnApiRequestB && (!areItemsReadyB)) && (
              /* Label */
              <Fade
                in={true}
                unmountOnExit
              >
                <div id='<%- sortedAssociations[aindex].relationNameOnPascal -%>ToAddTransferView-div-noDataB'>
                  <Grid container>
                    <Grid item xs={12}>
                      <Grid className={classes.noDataBox} container justify="center" alignItems="center">
                        <Grid item>
                          <Typography variant="body2" >{ t('modelPanels.noData') }</Typography>
                        </Grid>
                      </Grid>
                    </Grid>
                  </Grid>
                </div>
              </Fade>
            )}

            {/* Case: data ready */}
            {(thereAreItemsToAdd && !isOnApiRequestB && areItemsReadyB) && (
            
              /* List */
              <Fade
                in={true}
                unmountOnExit
              >
                <Box className={classes.listBox} ref={lrefB}>
                  <List id='<%- sortedAssociations[aindex].relationNameOnPascal -%>ToAddTransferView-list-listB'
                  dense component="div" role="list">
                    {itemsB.map(it => {
                      let key = it.<%- sortedAssociations[aindex].internalId _%>;
                      let label = <%- (sortedAssociations[aindex].label!==undefined && sortedAssociations[aindex].label!=='' && sortedAssociations[aindex].label !==  sortedAssociations[aindex].internalId) ? `it.${sortedAssociations[aindex].label}` : 'undefined' _%>;
                      let sublabel = <%- (sortedAssociations[aindex].sublabel!==undefined && sortedAssociations[aindex].sublabel!=='' && sortedAssociations[aindex].sublabel !==  sortedAssociations[aindex].label && sortedAssociations[aindex].sublabel !==  sortedAssociations[aindex].internalId) ? `it.${sortedAssociations[aindex].sublabel}` : 'undefined' _%>;

                      return (
                        <ListItem 
                          id={'<%- sortedAssociations[aindex].relationNameOnPascal -%>ToAddTransferView-listB-listItem-'+it.<%- sortedAssociations[aindex].internalId _%>}
                          key={key} 
                          role="listitem" 
                          button 
                          className={classes.row}
                          onClick={(event) => {
                            handleRowClicked(event, it);
                          }}
                        >
                          <ListItemAvatar>
                            <Tooltip title={ '<%- sortedAssociations[aindex].targetModel %>' }>
                              <Avatar>{"<%- sortedAssociations[aindex].targetModelLc%>".slice(0,1)}</Avatar>
                            </Tooltip>
                          </ListItemAvatar>

                          <ListItemText
                            primary={
                              <React.Fragment>
                                {/* <%- internalId _%> */}
                                <Grid container alignItems='center' alignContent='center' wrap='nowrap' spacing={1}>
                                  <Grid item>
                                    <Tooltip title={ '<%- sortedAssociations[aindex].internalId %>' }>
                                      <Typography variant="body1" display="block" noWrap={true}>{it.<%- sortedAssociations[aindex].internalId _%>}</Typography>
                                    </Tooltip>
                                  </Grid>
                                  {/*Key icon*/}
                                  <Grid item>
                                    <Tooltip title={ t('modelPanels.internalId', 'Unique Identifier') }>
                                      <Key fontSize="small" color="disabled" style={{ marginTop:8}} />
                                    </Tooltip>
                                  </Grid>
                                </Grid>
                              </React.Fragment>
                            }
                            secondary={
                              <React.Fragment>
                                {/* Label */}
                                {(label) && (
                                  <Tooltip title={ '<%- sortedAssociations[aindex].label %>' }>
                                    <Typography component="span" variant="body1" display="inline" color="textPrimary">{label}</Typography>
                                  </Tooltip>
                                )}
                                
                                {/* Sublabel */}
                                {(sublabel) && (
                                  <Tooltip title={ '<%- sortedAssociations[aindex].sublabel %>' }>
                                    <Typography component="span" variant="body2" display="inline" color='textSecondary'>{" — "+sublabel} </Typography>
                                  </Tooltip>
                                )}
                              </React.Fragment>
                            }
                          />
                          {/* Button: Remove */}
                          <ListItemSecondaryAction>
                            <Tooltip title={ t('modelPanels.untransferToAdd') }>
                              <IconButton
                                id={'<%- sortedAssociations[aindex].relationNameOnPascal -%>ToAddTransferView-listB-listItem-'+it.<%- sortedAssociations[aindex].internalId _%>+'-button-remove'}
                                color="primary"
                                onClick={(event) => {
                                  event.stopPropagation();
                                  handleRemoveItem(event, it);
                                }}
                              >
                                <Remove color="primary" />
                              </IconButton>
                            </Tooltip>
                          </ListItemSecondaryAction>
                        </ListItem>
                      );
                    })}
                  </List>
                </Box>
              </Fade>
            )}
            {/* Case: loading */}
            {( thereAreItemsToAdd && isOnApiRequestB) && (
              /* Progress */
              <Fade
                in={true}
                unmountOnExit
              >
                <div>
                  <Grid container>
                    <Grid item xs={12}>
                      <Box height={lhB}>
                        <Grid container className={classes.loadingBox} justify="center" alignItems="center">
                          <Grid item>
                            <CircularProgress color='primary' disableShrink />
                          </Grid>
                        </Grid>
                      </Box>
                    </Grid>
                  </Grid>
                </div>
              </Fade>
            )}

<%if( isToMany ) {-%>
            {/* Pagination */}
<%if(sortedAssociations[aindex].paginationType === 'limitOffset') {-%>
            <TablePagination
              rowsPerPageOptions={(countB <=10) ? [] : (countB <=50) ? [5, 10, 25, 50] : [5, 10, 25, 50, 100]}
              component="div"
              count={countB}
              rowsPerPage={rowsPerPageB}
              page={pageB}
              labelRowsPerPage = { t('modelPanels.rows', 'Rows') }
              labelDisplayedRows = {({ from, to }) => `${(countB<0) ? '': from}${(countB<0) ? '': '-'}${(countB<0) ? '': to} ${(countB<0) ? '': (isCountingB) ? '' : t('modelPanels.of')} ${(countB<0) ? '?': (isCountingB) ? '' : countB}`}
              onChangePage={handleChangePageB}
              onChangeRowsPerPage={handleChangeRowsPerPageB}
            />
<%} else if(sortedAssociations[aindex].paginationType === 'cursorBased') {-%>
            <<%- sortedAssociations[aindex].relationNameOnPascal _%>ToAddTransferViewCursorPagination
              count={countB}
              rowsPerPageOptions={(countB <=10) ? [] : (countB <=50) ? [5, 10, 25, 50] : [5, 10, 25, 50, 100]}
              rowsPerPage={(countB <=10) ? '' : rowsPerPageB}
              labelRowsPerPage = { t('modelPanels.rows', 'Rows') }
              hasNextPage={hasNextPageB}
              hasPreviousPage={hasPreviousPageB}
              handleFirstPageButtonClick={handleFirstPageButtonClickB}
              handleLastPageButtonClick={handleLastPageButtonClickB}
              handleNextButtonClick={handleNextButtonClickB}
              handleBackButtonClick={handleBackButtonClickB}
              handleChangeRowsPerPage={handleChangeRowsPerPageB}
            />
<%}-%>
<%}-%>
          </Card>
        </Grid>
      </Grid>
    </div>
  );
}
<%- sortedAssociations[aindex].relationNameOnPascal _%>ToAddTransferView.propTypes = {
  idsToAdd: PropTypes.array.isRequired,
  handleTransfer: PropTypes.func.isRequired,
  handleUntransfer: PropTypes.func.isRequired,
  handleClickOn<%- sortedAssociations[aindex].targetModelCp _%>Row: PropTypes.func.isRequired,
};