<%
/**
 * variables
 */
let isToOne = ( sortedAssociations[aindex].type === 'to_one' || sortedAssociations[aindex].type === 'generic_to_one' );
let isToMany = ( sortedAssociations[aindex].type === 'to_many' || sortedAssociations[aindex].type === 'to_many_through_sql_cross_table' || sortedAssociations[aindex].type === 'generic_to_many' );
let isCursorBased = ( sortedAssociations[aindex].paginationType === 'cursorBased' );
let isLimitOffset = ( sortedAssociations[aindex].paginationType === 'limitOffset' );
-%>

import React, { useState, useEffect, useRef, useCallback } from 'react';
import { useSelector } from 'react-redux';
import { makeStyles } from '@material-ui/core/styles';
import { useTranslation } from 'react-i18next';
import { useSnackbar } from 'notistack';
import Snackbar from '../../../../../../../../../snackbar/Snackbar';
import PropTypes from 'prop-types';
import api from '../../../../../../../../../../requests/requests.index.js';
import { makeCancelable } from '../../../../../../../../../../utils'
import <%- sortedAssociations[aindex].relationNameOnPascal _%>CompactViewToolbar from './components/<%- sortedAssociations[aindex].relationNameCp _%>CompactViewToolbar';
<%if( isToMany ){-%>
<%if(isCursorBased) {-%>
import <%- sortedAssociations[aindex].relationNameOnPascal _%>CompactViewCursorPagination from './components/<%- sortedAssociations[aindex].relationNameCp _%>CompactViewCursorPagination';
<%} else if(isLimitOffset) {-%>
import TablePagination from '@material-ui/core/TablePagination';
<%}}-%>
import Typography from '@material-ui/core/Typography';
import Tooltip from '@material-ui/core/Tooltip';
import Grid from '@material-ui/core/Grid';
import Box from '@material-ui/core/Box';
import Card from '@material-ui/core/Card';
import Button from '@material-ui/core/Button';
import CircularProgress from '@material-ui/core/CircularProgress';
import List from '@material-ui/core/List';
import ListItem from '@material-ui/core/ListItem';
import ListItemText from '@material-ui/core/ListItemText';
import ListItemAvatar from '@material-ui/core/ListItemAvatar';
import Avatar from '@material-ui/core/Avatar';
import Fade from '@material-ui/core/Fade';
import Key from '@material-ui/icons/VpnKey';

const useStyles = makeStyles(theme => ({
  root: {
    margin: theme.spacing(0),
    minWidth: 200,
  },
  card: {
    margin: theme.spacing(1),
    height: 'auto',
    maxHeight: `calc(64vh + 52px)`,
    overflow: 'auto',
    position: "relative",
  },
  listBox: {
    height: 'auto',
    minHeight: 82,
    maxHeight: '33vh',
    overflowY: 'auto',
    overflowX: 'hidden'
  },
  noDataBox: {
    width: "100%",
    height: 'auto',
    minHeight: 82,
    maxHeight: '33vh',
  },
  loadingBox: {
    width: "100%",
    height: '100%',
    maxHeight: '33vh',
  },
  row: {
    maxHeight: 70,
  },
}));

export default function <%- sortedAssociations[aindex].relationNameOnPascal _%>CompactView(props) {
  const classes = useStyles();
  const { t } = useTranslation();
  const { enqueueSnackbar, closeSnackbar } = useSnackbar();
  const {
    item,
    handleClickOn<%- sortedAssociations[aindex].targetModelCp _%>Row,
  } = props;

  const [items, setItems] = useState([]);
<%_if( isToMany ){-%>
  const [count, setCount] = useState(-1);
<%}-%>
  const [search, setSearch] = useState('');
  const [page, setPage] = useState(0);
<%_if( isToMany ){-%>
  const [rowsPerPage, setRowsPerPage] = useState(10);
<%}-%>
  const [isOnApiRequest, setIsOnApiRequest] = useState(false);
  const [areItemsReady, setAreItemsReady] = useState(false);
  const [dataTrigger, setDataTrigger] = useState(false);
  const isPendingApiRequestRef = useRef(false);
  const isOnApiRequestRef = useRef(false);
  const isGettingFirstDataRef = useRef(true);
  const pageRef = useRef(0);
<%_if( isToMany ){-%>
  const rowsPerPageRef = useRef(10);
<%}-%>
<%_if( isToMany ){-%>
<%if(isLimitOffset) {-%>
  const [isCounting, setIsCounting] = useState(true);
<%}-%>
  const isCountingRef = useRef(false);
<%if(isCursorBased) {-%>
  const [hasPreviousPage, setHasPreviousPage] = useState(false);
  const [hasNextPage, setHasNextPage] = useState(false);
  const pageInfo = useRef({startCursor: null, endCursor: null, hasPreviousPage: false, hasNextPage: false});
  const paginationRef = useRef({first: rowsPerPage, after: null, last: null, before: null, includeCursor: false});
  const isForwardPagination = useRef(true);
  const isCursorPaginating = useRef(false);
<%}-%>
  const cancelableCountingPromises = useRef([]);
<%}-%>
  const cancelablePromises = useRef([]);

  const graphqlServerUrl = useSelector(state => state.urls.graphqlServerUrl)
  const lastModelChanged = useSelector(state => state.changes.lastModelChanged);
  const lastChangeTimestamp = useSelector(state => state.changes.lastChangeTimestamp);
  const lastFetchTime = useRef(null);

  const lref = useRef(null);
  const [lh, setLh] = useState(82);

  //snackbar
  const variant = useRef('info');
  const errors = useRef([]);
  const content = useRef((key, message) => (
    <Snackbar id={key} message={message} errors={errors.current}
    variant={variant.current} />
  ));
  const actionText = useRef(t('modelPanels.gotIt', "Got it"));
  const action = useRef((key) => (
    <>
      <Button color='inherit' variant='text' size='small' 
      onClick={() => { closeSnackbar(key) }}>
        {actionText.current}
      </Button>
    </> 
  ));

<%_if( isToMany ){-%>
  //snackbar (for: getCount)
  const variantB = useRef('info');
  const errorsB = useRef([]);
  const contentB = useRef((key, message) => (
    <Snackbar id={key} message={message} errors={errorsB.current}
    variant={variantB.current} />
  ));
  const actionTextB = useRef(t('modelPanels.gotIt', "Got it"));
  const actionB = useRef((key) => (
    <>
      <Button color='inherit' variant='text' size='small' 
      onClick={() => { closeSnackbar(key) }}>
        {actionTextB.current}
      </Button>
    </> 
  ));
<%}-%>

   /**
    * Callbacks:
    *  showMessage
<%_if( isToMany ){-%>
    *  showMessageB
<%if(isCursorBased) {-%>
    *  configurePagination
    *  onEmptyPage
<%}-%>
<%}-%>
    *  clearRequestGetData
<%_if( isToMany ){-%>
    *  getCount
<%}-%>
    *  getData
    */

  /**
   * showMessage
   * 
   * Show the given message in a notistack snackbar.
   * 
   */
  const showMessage = useCallback((message, withDetail) => {
    enqueueSnackbar( message, {
      variant: variant.current,
      preventDuplicate: false,
      persist: true,
      action: !withDetail ? action.current : undefined,
      content: withDetail ? content.current : undefined,
    });
  },[enqueueSnackbar]);

<%_if( isToMany ){-%>
  /**
   * showMessageB
   * 
   * Show the given message in a notistack snackbar.
   * 
   */
  const showMessageB = useCallback((message, withDetail) => {
    enqueueSnackbar( message, {
      variant: variantB.current,
      preventDuplicate: false,
      persist: true,
      action: !withDetail ? actionB.current : undefined,
      content: withDetail ? contentB.current : undefined,
    });
  },[enqueueSnackbar]);

<%if(isCursorBased) {-%>
  /**
   * configurePagination
   * 
   * Set the configuration needed to perform a reload of data
   * in the given mode.
   */
  const configurePagination = useCallback((mode) => {
    switch(mode) {
      case "reset":
        //reset page info attributes
        pageInfo.current = {startCursor: null, endCursor: null, hasPreviousPage: false, hasNextPage: false};
        //set direction
        isForwardPagination.current = true;
        //set pagination attributes
        paginationRef.current = {
          first: rowsPerPageRef.current,
          after: null,
          last: null,
          before: null,
          includeCursor: false,
        }
        break;
      
      case "reload":
        //set direction
        isForwardPagination.current = true;
        //set pagination attributes
        paginationRef.current = {
          first: rowsPerPageRef.current,
          after: pageInfo.current.startCursor,
          last: null,
          before: null,
          includeCursor: true,
        }
        break;

      case "firstPage":
        //set direction
        isForwardPagination.current = true;
        //set pagination attributes
        paginationRef.current = {
          first: rowsPerPageRef.current,
          after: null,
          last: null,
          before: null,
          includeCursor: false,
        }
        break;

      case "lastPage":
        //set direction
        isForwardPagination.current = false;
        //set pagination attributes
        paginationRef.current = {
          first: null,
          after: null,
          last: rowsPerPageRef.current,
          before: null,
          includeCursor: false,
        }
        break;

      case "nextPage":
        //set direction
        isForwardPagination.current = true;
        //set pagination attributes
        paginationRef.current = {
          first: rowsPerPageRef.current,
          after: pageInfo.current.endCursor,
          last: null,
          before: null,
          includeCursor: false,
        }
        break;

      case "previousPage":
        //set direction
        isForwardPagination.current = false;
        //set pagination attributes
        paginationRef.current = {
          first: null,
          after: null,
          last: rowsPerPageRef.current,
          before: pageInfo.current.startCursor,
          includeCursor: false,
        }
        break;

      default: //reset
        //reset page info attributes
        pageInfo.current = {startCursor: null, endCursor: null, hasPreviousPage: false, hasNextPage: false};
        //set direction
        isForwardPagination.current = true;
        //set pagination attributes
        paginationRef.current = {
          first: rowsPerPageRef.current,
          after: null,
          last: null,
          before: null,
          includeCursor: false,
        }
        break;
    }
  }, []);
<%}-%>
<%}-%>


<%_if( isToMany ){-%>
<%if(isCursorBased) {-%>
  const onEmptyPage = useCallback((pi) => {
    //case: forward
    if(isForwardPagination.current) {
      if(pi && pi.hasPreviousPage) {
        //configure
        isOnApiRequestRef.current = false;
        isCursorPaginating.current = false;
        setIsOnApiRequest(false);
        configurePagination('previousPage');
        
        //reload
        setDataTrigger(prevDataTrigger => !prevDataTrigger);
        return;
      } else {
        //disable nextPage
        pageInfo.current.hasNextPage = false;
        setHasNextPage(pageInfo.current.hasNextPage);

        //configure pagination (default)
        configurePagination('reload');

        //ends request
        isOnApiRequestRef.current = false;
        isCursorPaginating.current = false;
        setIsOnApiRequest(false);

        //do not update items...
        return;
      }
    } else {//case: backward
      if(pi && pi.hasNextPage) {
        //configure
        isOnApiRequestRef.current = false;
        isCursorPaginating.current = false;
        setIsOnApiRequest(false);
        configurePagination('nextPage');
        
        //reload
        setDataTrigger(prevDataTrigger => !prevDataTrigger);
        return;
      } else {
        //disable previousPage
        pageInfo.current.hasPreviousPage = false;
        setHasPreviousPage(pageInfo.current.hasPreviousPage);

        //configure pagination (default)
        configurePagination('reload');

        //ends request
        isOnApiRequestRef.current = false;
        isCursorPaginating.current = false;
        setIsOnApiRequest(false);

        //do not update items...
        return;
      }
    }
  }, [configurePagination]);
<%}-%>
<%}-%>

  const clearRequestGetData = useCallback(() => {
<%if(isCursorBased  && isToMany) {-%>
    //configure pagination
    configurePagination('reset');
<%}-%>          
    setItems([]);
    isOnApiRequestRef.current = false;
    setIsOnApiRequest(false);
  },[<%if(isCursorBased && isToMany) {-%>configurePagination<%}-%>]);

<%
  /**
   * names
   */
  let methodName1 = 'getCount()';
  let requestName1 =  'api.'+nameLc+'.get'+sortedAssociations[aindex].relationNameCp+'Count';
-%>
<%_if( isToMany ){-%>
  /**
   * getCount
   * 
   * Get @count from GrahpQL Server.
   * Uses current state properties to fill query request.
   * Updates state to inform new @count retreived.
   * 
   */
  const getCount = useCallback(async () => {
    //return if there is an active count operation
    if(isCountingRef.current) return;

    cancelCountingPromises();
<%if(isLimitOffset) {-%>
    setIsCounting(true);
<%}-%>
    isCountingRef.current = true;
    errorsB.current = [];

    let c1 = makeCancelable( new Promise(resolve => {
      //set timeout
      window.setTimeout(function() {
        resolve("ok");
      }, 3000);
    }));
    cancelableCountingPromises.current.push(c1);
    await c1
      .promise
      .then(
      //resolved
      (response) => {
        //delete from cancelables
        cancelableCountingPromises.current.splice(cancelableCountingPromises.current.indexOf(c1), 1);
      },
      (err) => {
        console.log("c1.rejected: err - timeout:", err);
        if(err.isCanceled) return;
        else throw err;
      })
      //error
      .catch((err) => { //error: on api.individual.getCountItems
        console.log("c1.catch: err - timeout:", err);
        if(err.isCanceled) return;
        else throw err;
      });

    /*
      API Request: <%- requestName1 %>
    */
    let cancelableApiReq = makeCancelable(api.<%- nameLc _%>.get<%- sortedAssociations[aindex].relationNameCp _%>Count(
      graphqlServerUrl, 
      item.<%- internalId _%>,
      search,
    ));
    cancelableCountingPromises.current.push(cancelableApiReq);
    await cancelableApiReq
      .promise
      .then(
      //resolved
      (response) => {
        //delete from cancelables
        cancelableCountingPromises.current.splice(cancelableCountingPromises.current.indexOf(cancelableApiReq), 1);
        //check: response
        if(response.message === 'ok') {
          //check: graphql errors
          if(response.graphqlErrors) {
            let newError = {};
            let withDetails=true;
            variantB.current='info';
            newError.message = t('modelPanels.errors.data.e3', 'fetched with errors.');
            newError.locations=[{association: '<%- sortedAssociations[aindex].relationName _%>', method: '<%- methodName1 %>', request: '<%- requestName1 %>'}];
            newError.path=['detail', `<%- internalId _%>:${item.<%- internalId _%>}`, '<%- sortedAssociations[aindex].relationName _%>'];
            newError.extensions = {graphQL:{data:response.data, errors:response.graphqlErrors}};
            errorsB.current.push(newError);
            console.log("Error: ", newError);

            showMessageB(newError.message, withDetails);
          }
        } else { //not ok
          //show error
          let newError = {};
          let withDetails=true;
          variantB.current='error';
          newError.message = t(`modelPanels.errors.data.${response.message}`, 'Error: '+response.message);
          newError.locations=[{association: '<%- sortedAssociations[aindex].relationName _%>', method: '<%- methodName1 %>', request: '<%- requestName1 %>'}];
          newError.path=['detail', `<%- internalId _%>:${item.<%- internalId _%>}`, '<%- sortedAssociations[aindex].relationName _%>'];
          newError.extensions = {graphqlResponse:{data:response.data, errors:response.graphqlErrors}};
          errorsB.current.push(newError);
          console.log("Error: ", newError);
 
          showMessageB(newError.message, withDetails);
          return;
        }

        //ok
        setCount(response.value);
<%if(isLimitOffset) {-%>
        setIsCounting(false);
<%}-%>
        isCountingRef.current = false;

<%if(isLimitOffset) {-%>
        /*
          Check: empty page
        */
        if( (response.value === (pageRef.current * rowsPerPageRef.current)) && (pageRef.current > 0) ) 
        {
          isOnApiRequestRef.current = false;
          setIsOnApiRequest(false);
          setPage(pageRef.current - 1);
          return;
        }
        /*
          Check: page overflow
        */
        if((pageRef.current * rowsPerPageRef.current) > response.value) {
          isOnApiRequestRef.current = false;
          setIsOnApiRequest(false);
          setPage(Math.floor(response.value / rowsPerPageRef.current));
          return;
        }
<%}-%>
        return;
      },
      //rejected
      (err) => {
        if(err.isCanceled) return;
        else throw err;
      })
      //error
      .catch((err) => { //error: on <%- requestName1 %>
        if(err.isCanceled) {
          return;
        } else {
          let newError = {};
          let withDetails=true;
          variantB.current='error';
          newError.message = t('modelPanels.errors.request.e1', 'Error in request made to server.');
          newError.locations=[{association: '<%- sortedAssociations[aindex].relationName _%>', method: '<%- methodName1 %>', request: '<%- requestName1 %>'}];
          newError.path=['detail', `<%- internalId _%>:${item.<%- internalId _%>}`, '<%- sortedAssociations[aindex].relationName _%>'];
          newError.extensions = {error:{message:err.message, name:err.name, response:err.response}};
          errorsB.current.push(newError);
          console.log("Error: ", newError);

          showMessageB(newError.message, withDetails);
          return;
        }
      });

  }, [graphqlServerUrl, showMessageB, t, item.<%- internalId _%>, search]);
<%}-%>

<%
  /**
   * names
   */
  let methodName2 = 'getData()';
  let requestName2 = 'api.'+nameLc+'.get'+sortedAssociations[aindex].relationNameCp;
-%>
  /**
   * getData
   * 
   * Get @items from GrahpQL Server.
   * Uses current state properties to fill query request.
   * Updates state to inform new @items retreived.
   * 
   */
  const getData = useCallback(async () => {
    updateHeights();
    isOnApiRequestRef.current = true;
    setIsOnApiRequest(true);
    Boolean(dataTrigger); //avoid warning
    errors.current = [];

<%_if( isToMany ){-%>
    //count (async)
    getCount();
<%}-%>

    /*
      API Request: <%- requestName2 %>
    */
<%_if( isToMany ){-%>
<%if(isLimitOffset) {-%>
    let variables = {
      pagination: {offset: (pageRef.current * rowsPerPageRef.current), limit: rowsPerPageRef.current}
    };
<%} else if(isCursorBased) {-%>
    let variables = {
      pagination: {...paginationRef.current}
    };
<%}-%>
<%} else {-%>
    let variables = null;
<%}-%>
    /*
      API Request: <%- requestName2 %>
    */
    let cancelableApiReq = makeCancelable(api.<%- nameLc _%>.get<%- sortedAssociations[aindex].relationNameCp _%>(
      graphqlServerUrl, 
      item.<%- internalId _%>,
      search,
      variables,
    ));
    cancelablePromises.current.push(cancelableApiReq);
    await cancelableApiReq
      .promise
      .then(
      //resolved
      (response) => {
        //delete from cancelables
        cancelablePromises.current.splice(cancelablePromises.current.indexOf(cancelableApiReq), 1);
        //check: response
        if(response.message === 'ok') {
          //check: graphql errors
          if(response.graphqlErrors) {
            let newError = {};
            let withDetails=true;
            variant.current='info';
            newError.message = t('modelPanels.errors.data.e3', 'fetched with errors.');
            newError.locations=[{association: '<%- sortedAssociations[aindex].relationName _%>', method: '<%- methodName2 %>', request: '<%- requestName2 %>'}];
            newError.path=['detail', `<%- internalId _%>:${item.<%- internalId _%>}`, '<%- sortedAssociations[aindex].relationName _%>'];
            newError.extensions = {graphQL:{data:response.data, errors:response.graphqlErrors}};
            errors.current.push(newError);
            console.log("Error: ", newError);

            showMessage(newError.message, withDetails);
          }
        } else { //not ok
          //show error
          let newError = {};
          let withDetails=true;
          variant.current='error';
          newError.message = t(`modelPanels.errors.data.${response.message}`, 'Error: '+response.message);
          newError.locations=[{association: '<%- sortedAssociations[aindex].relationName _%>', method: '<%- methodName2 %>', request: '<%- requestName2 %>'}];
          newError.path=['detail', `<%- internalId _%>:${item.<%- internalId _%>}`, '<%- sortedAssociations[aindex].relationName _%>'];
          newError.extensions = {graphqlResponse:{data:response.data, errors:response.graphqlErrors}};
          errors.current.push(newError);
          console.log("Error: ", newError);
  
          showMessage(newError.message, withDetails);
          clearRequestGetData();
          return;
        }

<%_if( isToMany ){-%>
<%# 
/**
 * Case: to_many
 */ 
-%>
<%if(isLimitOffset) {-%>
        //get items
        let its = response.value;
<%} else if(isCursorBased) {-%>
        //get items
        let its = response.value.edges.map(o => o.node);
        let pi = response.value.pageInfo;

        /*
          Check: empty page
        */
        if( its.length === 0 ) 
        {
          onEmptyPage(pi);
          return;
        }

        //update pageInfo
        pageInfo.current = pi;
        setHasPreviousPage(pageInfo.current.hasPreviousPage);
        setHasNextPage(pageInfo.current.hasNextPage);

        //configure pagination (default)
        configurePagination('reload');
<%}-%>

        //ok
        setItems([...its]);

        //ends request
        isOnApiRequestRef.current = false;
<%if(isCursorBased) {-%>
        isCursorPaginating.current = false;
<%}-%>
<%} else {-%> 
<%# 
/**
 * Case: to_one
 */ 
-%>
        //get item
        let it = response.value;
        //ok
        setItems((it) ? [it] : []);

        //ends request
        isOnApiRequestRef.current = false;
<%}-%>
        setIsOnApiRequest(false);
        return;
      },
      //rejected
      (err) => {
        throw err;
      })
      //error
      .catch((err) => { //error: on <%- requestName2 %>
        if(err.isCanceled) {
          return;
        } else {
          let newError = {};
          let withDetails=true;
          variant.current='error';
          newError.message = t('modelPanels.errors.request.e1', 'Error in request made to server.');
          newError.locations=[{association: '<%- sortedAssociations[aindex].relationName _%>', method: '<%- methodName2 %>', request: '<%- requestName2 %>'}];
          newError.path=['detail', `<%- internalId _%>:${item.<%- internalId _%>}`, '<%- sortedAssociations[aindex].relationName _%>'];
          newError.extensions = {error:{message:err.message, name:err.name, response:err.response}};
          errors.current.push(newError);
          console.log("Error: ", newError);

          showMessage(newError.message, withDetails);
          clearRequestGetData();
          return;
        }
      });

  }, [graphqlServerUrl, showMessage, clearRequestGetData, t, dataTrigger, item.<%- internalId _%>, search<%if( isToMany ) {-%>, getCount<%}-%><%if( isToMany && isCursorBased ) {-%>, configurePagination, onEmptyPage<%}-%>]);

  useEffect(() => {

    //cleanup on unmounted.
    return function cleanup() {
      cancelablePromises.current.forEach(p => p.cancel());
      cancelablePromises.current = [];
<%_if( isToMany ){-%>
      cancelableCountingPromises.current.forEach(p => p.cancel());
      cancelableCountingPromises.current = [];
<%}-%>
    };
  }, []);
  
  useEffect(() => {
    if (!isOnApiRequestRef.current) {
      getData();
    } 
    else { 
      isPendingApiRequestRef.current = true; 
    }
  }, [getData]);

  useEffect(() => {
    /*
     * Handle changes 
     */

    /*
     * Checks
     */
    if(!lastModelChanged) {
      return;
    }
    if(!lastChangeTimestamp || !lastFetchTime.current) {
      return;
    }
    let isNewChange = (lastFetchTime.current<lastChangeTimestamp);
    if(!isNewChange) {
      return;
    }

    /*
     * Update timestamps
     */
    lastFetchTime.current = Date.now();

    /*
     * Case 1:
     * The relation '<%- sortedAssociations[aindex].relationName _%>' for this item was updated from the target model (in the peer relation).
     * That is to say that this current item was associated or dis-associated with some '<%- sortedAssociations[aindex].targetModel _%>',
     * but this action happened on the peer relation, identified by '<%- sortedAssociations[aindex].keyRelationName _%>'.
     * 
     * Conditions:
     * A: the current item 'internalId' attribute is in the removedIds of the updated '<%- sortedAssociations[aindex].targetModel _%>'.
     * B: the current item 'internalId' attribute is in the addedIds of the updated '<%- sortedAssociations[aindex].targetModel _%>'.
     * 
     * Actions:
     * if A:
     * - reload table.
     * - return
     * 
     * else if B:
     * - reload table.
     * - return
     */
    if(lastModelChanged.<%- sortedAssociations[aindex].targetModel _%>) {
      let oens = Object.entries(lastModelChanged.<%- sortedAssociations[aindex].targetModel _%>);
      oens.forEach( (entry) => {
        if(entry[1].changedAssociations&&
          entry[1].changedAssociations.<%- sortedAssociations[aindex].keyRelationName _%>) {

            //case A: this item was removed from peer relation.
            if(entry[1].changedAssociations.<%- sortedAssociations[aindex].keyRelationName _%>.removed) {
              let idsRemoved = entry[1].changedAssociations.<%- sortedAssociations[aindex].keyRelationName _%>.idsRemoved;
              if(idsRemoved) {
                let iof = idsRemoved.indexOf(item.<%- internalId _%>);
                if(iof !== -1) {
<%_if( isToMany ){-%>
                  //increment A
                  setCount(count+1);
                  //will count
                  cancelCountingPromises();
                  isCountingRef.current = false;
<%}-%>

<%if(isLimitOffset) {-%>
                  //reload
                  if (!isOnApiRequestRef.current) { setDataTrigger(prevDataTrigger => !prevDataTrigger); }
<%_if( isToMany ){-%>
                  else { isPendingApiRequestRef.current = true; getCount(); }
<%} else {-%>
                  else { isPendingApiRequestRef.current = true; }
<%}-%> 
<%} else if(isCursorBased) {-%>
                  //strict contention
<%_if( isToMany ){-%>
                  if (!isOnApiRequestRef.current && !isCursorPaginating.current) {
                    //configure
                    configurePagination('reload');
                    //reload
                    setDataTrigger(prevDataTrigger => !prevDataTrigger);
                  } else {
                    getCount();
                  }
<%} else {-%>
                  if (!isOnApiRequestRef.current) {
                    //reload
                    setDataTrigger(prevDataTrigger => !prevDataTrigger);
                  }
<%}-%>
<%}-%>
                  return;
                }
              }
            }//end: case A

            //case B: this item was added on peer relation.
            if(entry[1].changedAssociations.<%- sortedAssociations[aindex].keyRelationName _%>.added) {
              let idsAdded = entry[1].changedAssociations.<%- sortedAssociations[aindex].keyRelationName _%>.idsAdded;
              if(idsAdded) {
                let iof = idsAdded.indexOf(item.<%- internalId _%>);
                if(iof !== -1) {
<%_if( isToMany ){-%>
                  //increment
                  setCount(count+1);
                  //will count
                  cancelCountingPromises();
                  isCountingRef.current = false;
<%}-%>
<%if(isLimitOffset) {-%>
                  //reload
                  if (!isOnApiRequestRef.current) { setDataTrigger(prevDataTrigger => !prevDataTrigger); }
<%_if( isToMany ){-%>
                  else { isPendingApiRequestRef.current = true; getCount(); }
<%} else {-%>
                  else { isPendingApiRequestRef.current = true; }
<%}-%> 
<%} else if(isCursorBased) {-%>
                  //strict contention
<%_if( isToMany ){-%>
                  if (!isOnApiRequestRef.current && !isCursorPaginating.current) {
                    //configure
                    configurePagination('reload');
                    //reload
                    setDataTrigger(prevDataTrigger => !prevDataTrigger);
                  } else {
                    getCount();
                  }
<%} else {-%>
                  if (!isOnApiRequestRef.current) {
                    //reload
                    setDataTrigger(prevDataTrigger => !prevDataTrigger);
                  }
<%}-%>
<%}-%>
                  return;
                }
              }
            }//end: case B
        }
      })
    }//end: Case 1

    /*
     * Case 2: 
     * The attributes of some '<%- sortedAssociations[aindex].targetModel _%>' were modified or the item was deleted.
     * 
     * Conditions:
     * A: the item was modified and is currently displayed in the list.
     * B: the item was deleted and is currently displayed the  list.
     * 
     * Actions:
     * if A:
     * - update the list with the new item.
     * - return
     * 
     * if B:
     * - reload table.
     * - return
     */
    if(lastModelChanged.<%- sortedAssociations[aindex].targetModel _%>) {

      let oens = Object.entries(lastModelChanged.<%- sortedAssociations[aindex].targetModel _%>);
      oens.forEach( (entry) => {
<%#
/**
 * Special case: user model
 */
-%>
<% if(sortedAssociations[aindex].targetModelLc==='user') {%>
        //case A: updated || updated password
        if((entry[1].op === "update" || entry[1].op === "updatePassword")&&entry[1].newItem) {
<%} else {-%>
        //case A: updated
        if(entry[1].op === "update"&&entry[1].newItem) {
<%}-%>
          let idUpdated = entry[1].item.<%- sortedAssociations[aindex].internalId _%>;
          
          //lookup item on table
          let nitemsA = Array.from(items);
          let iofA = nitemsA.findIndex((item) => item.<%- sortedAssociations[aindex].internalId _%>===idUpdated);
          if(iofA !== -1) {
            //set new item
            nitemsA[iofA] = entry[1].newItem;
            setItems(nitemsA);
          }
        }

        //case B: deleted
        if(entry[1].op === "delete") {
<%_if( isToMany ){-%>
          let idRemoved = entry[1].item.<%- sortedAssociations[aindex].internalId _%>;
          //lookup item on table
          let iofA = items.findIndex((item) => item.<%- sortedAssociations[aindex].internalId _%>===idRemoved);
          if(iofA !== -1) {
            //decrement A
            setCount(count-1);
          }
          //will count
          cancelCountingPromises();
          isCountingRef.current = false;
<%}-%>

<%if(isLimitOffset) {-%>
          //reload
          if (!isOnApiRequestRef.current) { setDataTrigger(prevDataTrigger => !prevDataTrigger); }
<%_if( isToMany ){-%>
          else { isPendingApiRequestRef.current = true; getCount(); }
<%} else{-%>
          else { isPendingApiRequestRef.current = true; }
<%}-%>
<%} else if(isCursorBased) {-%>
          //strict contention
<%_if( isToMany ){-%>
          if (!isOnApiRequestRef.current && !isCursorPaginating.current) {
            //configure
            configurePagination('reload');
            //reload
            setDataTrigger(prevDataTrigger => !prevDataTrigger);
          } else {
            getCount();
          }
<%} else {-%>
          if (!isOnApiRequestRef.current) {
            //reload
            setDataTrigger(prevDataTrigger => !prevDataTrigger);
          }
<%}-%>
<%}-%>
          return;
        }
      });
    }//end: Case 2
  }, [lastModelChanged, lastChangeTimestamp, items, item.<%- internalId _%><%_if( isToMany ){-%>, count, getCount<%}-%><%_if( isToMany && isCursorBased ){-%>, configurePagination<%}-%>]);

  useEffect(() => {
    //return if this flag is set
    if(isGettingFirstDataRef.current) { 
      isGettingFirstDataRef.current = false; 
      return; 
    } 
    else {
      //get data from the new page
      pageRef.current = page;
      if (!isOnApiRequestRef.current) {
        setDataTrigger(prevDataTrigger => !prevDataTrigger); 
      } 
      else { 
        isPendingApiRequestRef.current = true; 
      }
    }
  }, [page]);

<%_if( isToMany ){-%>
<%if(isLimitOffset) {-%>
  useEffect(() => {
    //update ref
    rowsPerPageRef.current = rowsPerPage;

    //check strict contention
    if(isOnApiRequestRef.current) { return; }

    //reload
    setDataTrigger(prevDataTrigger => !prevDataTrigger);
  }, [rowsPerPage]);
<%} else if(isCursorBased) {-%>
  useEffect(() => {
    //update ref
    rowsPerPageRef.current = rowsPerPage;

    //check strict contention
    if(isOnApiRequestRef.current || isCursorPaginating.current) { return; }
    //set strict contention
    isCursorPaginating.current = true;
    
    //configure pagination
    configurePagination('reset');
    //reload    
    setDataTrigger(prevDataTrigger => !prevDataTrigger);
  }, [rowsPerPage, configurePagination]);
<%}-%>
<%}-%>

  useEffect(() => {
    if (!isOnApiRequest && isPendingApiRequestRef.current) {
      isPendingApiRequestRef.current = false;
<%if(isLimitOffset) {-%>
      //reload
      setDataTrigger(prevDataTrigger => !prevDataTrigger);
<%} else if(isCursorBased) {-%>
<%_if( isToMany ){-%>
      //configure
      configurePagination('reload');
<%}-%>
      //reload
      setDataTrigger(prevDataTrigger => !prevDataTrigger);
<%}-%>
    }
    updateHeights();
  }, [isOnApiRequest<%if(isCursorBased && isToMany) {-%>, configurePagination<%}-%>]);

  useEffect(() => {
    if(Array.isArray(items) && items.length > 0) { 
      setAreItemsReady(true); 
    } else { 
      setAreItemsReady(false); 
    }
    lastFetchTime.current = Date.now();
  }, [items]);

  /**
   * Utils
   */
<%_if( isToMany ){-%>
  function cancelCountingPromises() {
    cancelableCountingPromises.current.forEach(p => p.cancel());
    cancelableCountingPromises.current = [];    
  }
<%}-%>

  function updateHeights() {
    if(lref.current) {
      let h =lref.current.clientHeight;
      setLh(h);
    }
  }

<%if(isLimitOffset) {-%>
  function resetPageRefs() {
    pageRef.current = 0;
  }

  function resetReloadData() {
    //reload A
    resetPageRefs();
    if (!isOnApiRequestRef.current) { setDataTrigger(prevDataTrigger => !prevDataTrigger); } 
    else { isPendingApiRequestRef.current = true; }
  }
<%}-%>

  /**
   * Handlers
   */

  /*
   * Search handlers
   */
  const handleSearchEnter = text => {
    if(text !== search)
    {
<%if(isLimitOffset) {-%>
      resetPageRefs();
<%}-%>
      if(page !== 0) {
        isGettingFirstDataRef.current = true; //avoids to get data on [page] effect
        setPage(0);
      }
<%_if( isToMany ){-%>
      setCount(-1);
      //will count
      cancelCountingPromises();
      isCountingRef.current = false;
<%}-%>

      setSearch(text);
    }
  };

  /*
   * Pagination handlers
   */

<%_if( isToMany ){-%>
<%if(isLimitOffset) {-%>
  const handleChangePage = (event, newPage) => {
    setPage(newPage);
  };
<%}-%>
<%}-%>

<%_if( isToMany ){-%>
<%if(isCursorBased) {-%>
  const handleFirstPageButtonClick = (event) => {
    //strict contention
    if (isOnApiRequestRef.current || isCursorPaginating.current) { return; }
    //set strict contention
    isCursorPaginating.current = true;
    //configure A
    configurePagination('firstPage');
    //reload A
    setDataTrigger(prevDataTrigger => !prevDataTrigger);
  };

  const handleLastPageButtonClick = (event) => {
    //strict contention
    if (isOnApiRequestRef.current || isCursorPaginating.current) { return; }
    //set strict contention
    isCursorPaginating.current = true;
    //configure A
    configurePagination('lastPage');
    //reload A
    setDataTrigger(prevDataTrigger => !prevDataTrigger);
  };

  const handleNextButtonClick = (event) => {
    //strict contention
    if (isOnApiRequestRef.current || isCursorPaginating.current) { return; }
    //set strict contention
    isCursorPaginating.current = true;
    //configure A
    configurePagination('nextPage');
    //reload A
    setDataTrigger(prevDataTrigger => !prevDataTrigger);
  };

  const handleBackButtonClick = (event) => {
    //strict contention
    if (isOnApiRequestRef.current || isCursorPaginating.current) { return; }
    //set strict contention
    isCursorPaginating.current = true;
    //configure A
    configurePagination('previousPage');
    //reload A
    setDataTrigger(prevDataTrigger => !prevDataTrigger);
  };
<%}-%>
<%}-%>

<%_if( isToMany ){-%>
  const handleChangeRowsPerPage = event => {
    if(event.target.value !== rowsPerPage)
    {
  <%if(isLimitOffset) {-%>
      resetPageRefs();
  <%}-%>
      if(page !== 0) {
        isGettingFirstDataRef.current = true; //avoids to get data on [page] effect
        setPage(0);
      }
  
      setRowsPerPage(parseInt(event.target.value, 10));
    }
  };
<%}-%>

<%if(isLimitOffset) {-%>
  const handleReloadClick = (event) => {
    resetReloadData();
  };
<%} else if(isCursorBased) {-%>
  const handleReloadClick = (event) => {
<%_if( isToMany ){-%>
    //check strict contention
    if(isOnApiRequestRef.current || isCursorPaginating.current) { return; }
    //set strict contention
    isCursorPaginating.current = true;
    //configure pagination
    configurePagination('reset');
    //reload
    setDataTrigger(prevDataTrigger => !prevDataTrigger);
<%} else {-%>
    //check strict contention
    if(isOnApiRequestRef.current) { return; }
    //reload
    setDataTrigger(prevDataTrigger => !prevDataTrigger);
<%}-%>
  };
<%}-%>

  /**
   * Items handlers
   */
  const handleRowClicked = (event, item) => {
    handleClickOn<%- sortedAssociations[aindex].targetModelCp _%>Row(event, item);
  }

  return (
    <div className={classes.root}>
      <Grid container>
        {/*
          * Compact List
          */}
        <Grid item xs={12} >
          {(item!==undefined) && (
            <Card className={classes.card}>

              {/* Toolbar */}
              <<%- sortedAssociations[aindex].relationNameOnPascal _%>CompactViewToolbar 
                title={'<%- (isToOne) ? sortedAssociations[aindex].targetModelCp : sortedAssociations[aindex].targetModelPlCp %>'}
                search={search}
                onSearchEnter={handleSearchEnter}
                onReloadClick={handleReloadClick}
              />

              {/* Case: no data */}
              {(!isOnApiRequest && (!areItemsReady)) && (
                /* Label */
                <Fade
                  in={true}
                  unmountOnExit
                >
                  <div id='<%- sortedAssociations[aindex].relationNameOnPascal -%>CompactView-div-noDataA'>
                    <Grid container>
                      <Grid item xs={12}>
                        <Grid className={classes.noDataBox} container justify="center" alignItems="center">
                          <Grid item>
                            <Typography variant="body1" >{ t('modelPanels.noData') }</Typography>
                          </Grid>
                        </Grid>
                      </Grid>
                    </Grid>
                  </div>
                </Fade>
              )}

              {/* Case: data ready */}
              {(!isOnApiRequest && areItemsReady) && (
              
                /* List */
                <Fade
                  in={true}
                  unmountOnExit
                >
                  <Box className={classes.listBox} ref={lref}>
                    <List id='<%- sortedAssociations[aindex].relationNameOnPascal -%>CompactView-list-listA'
                    dense component="div" role="list" >
                      {items.map(it => {
                        let key = it.<%- sortedAssociations[aindex].internalId _%>;
                        let label = <%- (sortedAssociations[aindex].label!==undefined && sortedAssociations[aindex].label!=='' && sortedAssociations[aindex].label !==  sortedAssociations[aindex].internalId) ? `it.${sortedAssociations[aindex].label}` : 'undefined' _%>;
                        let sublabel = <%- (sortedAssociations[aindex].sublabel!==undefined && sortedAssociations[aindex].sublabel!=='' && sortedAssociations[aindex].sublabel !==  sortedAssociations[aindex].label && sortedAssociations[aindex].sublabel !==  sortedAssociations[aindex].internalId) ? `it.${sortedAssociations[aindex].sublabel}` : 'undefined' _%>;
       
                        return (
                          <ListItem 
                            id={'<%- sortedAssociations[aindex].relationNameOnPascal -%>CompactView-listA-listItem-'+it.<%- sortedAssociations[aindex].internalId _%>}
                            key={key} 
                            role="listitem" 
                            button 
                            className={classes.row}
                            onClick={(event) => {
                              handleRowClicked(event, it);
                            }}
                          >
                            <ListItemAvatar>
                              <Tooltip title={ '<%- sortedAssociations[aindex].targetModel %>' }>
                                <Avatar>{"<%- sortedAssociations[aindex].targetModelLc%>".slice(0,1)}</Avatar>
                              </Tooltip>
                            </ListItemAvatar>

                            <ListItemText
                              primary={
                                <React.Fragment>
                                  {/* <%- internalId _%> */}
                                  <Grid container alignItems='center' alignContent='center' wrap='nowrap' spacing={1}>
                                    <Grid item>
                                      <Tooltip title={ '<%- sortedAssociations[aindex].internalId %>' }>
                                        <Typography
                                        id={'<%- sortedAssociations[aindex].relationNameOnPascal -%>CompactView-listA-listItem-id-'+it.<%- sortedAssociations[aindex].internalId _%>}
                                        variant="body1" display="block" noWrap={true}>{it.<%- sortedAssociations[aindex].internalId _%>}</Typography>
                                      </Tooltip>
                                    </Grid>
                                    {/*Key icon*/}
                                    <Grid item>
                                      <Tooltip title={ t('modelPanels.internalId', 'Unique Identifier') }>
                                        <Key fontSize="small" color="disabled" style={{ marginTop:8}} />
                                      </Tooltip>
                                    </Grid>
                                  </Grid>
                                </React.Fragment>
                              }
                              secondary={
                                <React.Fragment>
                                  {/* Label */}
                                  {(label) && (
                                    <Tooltip title={ '<%- sortedAssociations[aindex].label %>' }>
                                      <Typography
                                      id={'<%- sortedAssociations[aindex].relationNameOnPascal -%>CompactView-listA-listItem-label-'+it.<%- sortedAssociations[aindex].internalId _%>}
                                      component="span" variant="body1" display="inline" color="textPrimary">{label}</Typography>
                                    </Tooltip>
                                  )}
                                  
                                  {/* Sublabel */}
                                  {(sublabel) && (
                                    <Tooltip title={ '<%- sortedAssociations[aindex].sublabel %>' }>
                                      <Typography
                                      id={'<%- sortedAssociations[aindex].relationNameOnPascal -%>CompactView-listA-listItem-sublabel-'+it.<%- sortedAssociations[aindex].internalId _%>}
                                      component="span" variant="body2" display="inline" color='textSecondary'>{" — "+sublabel} </Typography>
                                    </Tooltip>
                                  )}
                                </React.Fragment>
                              }
                            />
                          </ListItem>
                        );
                      })}
                    </List>
                  </Box>
                </Fade>
              )}
              {/* Case: loading */}
              {(isOnApiRequest) && (
                /* Progress */
                <Fade
                  in={true}
                  unmountOnExit
                >
                  <div>
                    <Grid container>
                      <Grid item xs={12}>
                        <Box height={lh}>
                          <Grid container className={classes.loadingBox} justify="center" alignItems="center">
                            <Grid item>
                              <CircularProgress color='primary' disableShrink />
                            </Grid>
                          </Grid>
                        </Box>
                      </Grid>
                    </Grid>
                  </div>
                </Fade>
              )}

<%if( isToMany ) {-%>
              {/* Pagination */}
<%if(isLimitOffset) {-%>
              <TablePagination
                rowsPerPageOptions={(count <=10) ? [] : (count <=50) ? [5, 10, 25, 50] : [5, 10, 25, 50, 100]}
                component="div"
                count={count}
                rowsPerPage={rowsPerPage}
                page={page}
                labelRowsPerPage = { t('modelPanels.rows', 'Rows') }
                labelDisplayedRows = {({ from, to }) => `${(count<0) ? '': from}${(count<0) ? '': '-'}${(count<0) ? '': to} ${(count<0) ? '': (isCounting) ? '' : t('modelPanels.of')} ${(count<0) ? '?': (isCounting) ? '' : count}`}
                onChangePage={handleChangePage}
                onChangeRowsPerPage={handleChangeRowsPerPage}
              />
<%} else if(isCursorBased) {-%>
              <<%- sortedAssociations[aindex].relationNameOnPascal _%>CompactViewCursorPagination
                count={count}
                rowsPerPageOptions={(count <=10) ? [] : (count <=50) ? [5, 10, 25, 50] : [5, 10, 25, 50, 100]}
                rowsPerPage={(count <=10) ? '' : rowsPerPage}
                labelRowsPerPage = { t('modelPanels.rows', 'Rows') }
                hasNextPage={hasNextPage}
                hasPreviousPage={hasPreviousPage}
                handleFirstPageButtonClick={handleFirstPageButtonClick}
                handleLastPageButtonClick={handleLastPageButtonClick}
                handleNextButtonClick={handleNextButtonClick}
                handleBackButtonClick={handleBackButtonClick}
                handleChangeRowsPerPage={handleChangeRowsPerPage}
              />
<%}-%>
<%}-%>
            </Card>
          )}
        </Grid>
      </Grid>
    </div>
  );
}
<%- sortedAssociations[aindex].relationNameOnPascal _%>CompactView.propTypes = {
  item: PropTypes.object.isRequired,
  handleClickOn<%- sortedAssociations[aindex].relationNameCp _%>Row: PropTypes.func,
};